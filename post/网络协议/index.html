<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>网络协议 - OxO</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="zs" /><meta name="description" content="" /><meta name="keywords" content="网络协议" />






<meta name="generator" content="Hugo 0.84.3 with theme even" />


<link rel="canonical" href="https://zs368.github.io/post/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.24752eee7d244519907709610f39db5d85a57e527ff033fcae4457858307d262.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="网络协议" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zs368.github.io/post/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-10-15T23:30:51&#43;08:00" />
<meta property="article:modified_time" content="2020-10-15T23:30:51&#43;08:00" />

<meta itemprop="name" content="网络协议">
<meta itemprop="description" content=""><meta itemprop="datePublished" content="2020-10-15T23:30:51&#43;08:00" />
<meta itemprop="dateModified" content="2020-10-15T23:30:51&#43;08:00" />
<meta itemprop="wordCount" content="29154">
<meta itemprop="keywords" content="计算机基础," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="网络协议"/>
<meta name="twitter:description" content=""/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">zs368</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/info/">
        <li class="mobile-menu-item">Info</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">zs368</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/info/">Info</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">网络协议</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-10-15 </span>
        
          <span class="more-meta"> 29154 words </span>
          <span class="more-meta"> 59 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#网络基础">网络基础</a>
      <ul>
        <li><a href="#网络请求">网络请求</a></li>
        <li><a href="#从物理层到链路层">从物理层到链路层</a></li>
        <li><a href="#常见命令">常见命令</a></li>
      </ul>
    </li>
    <li><a href="#网络层协议">网络层协议</a>
      <ul>
        <li><a href="#ip协议">IP协议</a></li>
        <li><a href="#路由协议">路由协议</a></li>
      </ul>
    </li>
    <li><a href="#传输层协议">传输层协议</a>
      <ul>
        <li><a href="#tcp协议">TCP协议</a></li>
        <li><a href="#udp协议">UDP协议</a></li>
        <li><a href="#socket编程">SOCKET编程</a></li>
      </ul>
    </li>
    <li><a href="#应用层协议">应用层协议</a>
      <ul>
        <li><a href="#远程登录协议">远程登录协议</a></li>
        <li><a href="#文件传输协议">文件传输协议</a></li>
        <li><a href="#电子邮件协议">电子邮件协议</a></li>
      </ul>
    </li>
    <li><a href="#http协议">HTTP协议</a>
      <ul>
        <li><a href="#报文">报文</a></li>
        <li><a href="#web服务器">WEB服务器</a></li>
        <li><a href="#php-fpm">PHP-FPM</a></li>
        <li><a href="#lnmp">LNMP</a></li>
        <li><a href="#http缓存">HTTP缓存</a></li>
        <li><a href="#cdn缓存">CDN缓存</a></li>
        <li><a href="#https">HTTPS</a></li>
        <li><a href="#http认证">HTTP认证</a></li>
        <li><a href="#websocket"><strong>WebSocket</strong></a></li>
        <li><a href="#http20">HTTP2.0</a></li>
      </ul>
    </li>
    <li><a href="#流媒体协议">流媒体协议</a>
      <ul>
        <li><a href="#视频压缩和编码"><strong>视频压缩和编码</strong></a></li>
        <li><a href="#常见流媒体协议"><strong>常见流媒体协议</strong></a></li>
        <li><a href="#基于rtmp的视频直播流程"><strong>基于RTMP的视频直播流程</strong></a></li>
        <li><a href="#流媒体cdn"><strong>流媒体CDN</strong></a></li>
      </ul>
    </li>
    <li><a href="#rpc协议">RPC协议</a></li>
    <li><a href="#推荐阅读">推荐阅读</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="网络基础">网络基础</h2>
<p><img src="/img/network-protocol_1.png" alt=""></p>
<h3 id="网络请求">网络请求</h3>
<p><strong>客户端</strong></p>
<ol>
<li>
<p>输入网站的域名</p>
</li>
<li>
<p><strong>DNS 协议</strong>对域名进行解析</p>
</li>
<li>
<p>浏览器就开始打包本次请求，这里根据传输数据加密与否分为 HTTP 请求和 HTTPS 请求</p>
<blockquote>
<p>DNS、HTTP、HTTPS 所在的层是应用层，经过应用层封装后，浏览器将应用层的包交个下一层（传输层）去完成，这个过程通过 Socket 编程来实现</p>
</blockquote>
</li>
<li>
<p>传输层有两种协议：无连接的 <strong>UDP 协议</strong>，面向连接的 <strong>TCP 协议</strong></p>
<ul>
<li>UDP 协议：无需建立连接即可通信，但是不可靠，可能会丢包</li>
<li>TCP 协议：要三次握手建立连接，能够保证数据包达到目的地，但是性能和速度不如 UDP</li>
</ul>
<blockquote>
<p>对于 HTTP/HTTPS 请求来说，都是基于 TCP 协议的可靠连接，TCP 协议有两个端口，一个是浏览器监听的端口（监听服务器响应），一个是服务器监听的端口（监听客户端请求， 80 端口或者 443 端口）</p>
</blockquote>
</li>
<li>
<p>传输层封装完成后，浏览器将包交给操作系统的网络层，网络层的协议是 <strong>IP 协议</strong>，在这一层，会给传输层传递过来的包加上 IP 头</p>
<blockquote>
<p>操作系统知道目标机器 IP 地址后，就开始根据它来寻找目标机器，如果是本机局域网内的机器，可以直接通过 IP 地址判断出来，如果是局域网之外的机器，则需要通过网关去外面的世界查找</p>
</blockquote>
</li>
<li>
<p>操作系统启动的时候，就会通过 DHCP 协议配置 IP 地址，以及默认网关的 IP 地址：192.168.1.1。操作系统会通过 <strong>ARP 协议</strong>通过 IP 地址获取网关的 MAC 地址，并将本地网关和计算机的 MAC 地址添加到 MAC 头中。这样，操作系统就将 IP 包从<strong>网络层</strong>交给了下一层 —— <strong>链路层</strong>，再经由网卡发送出去（客户端机器与网关之间还有物理层的线路连接）</p>
</li>
<li>
<p>网关收到包以后，会根据自己的知识判断下一步怎么走，网关往往是一个路由器，到某个目标 IP 地址怎么走，有一个路由表。网络请求包往往需要经过多个网关的跳转，才能达到最终的目标机器。</p>
</li>
<li>
<p>假设网络包经过多个网关之后，最终到达了目标服务器所在的网关，通过 ARP 协议，目标服务器根据目标 IP 地址返回一个 MAC 地址，表示目标服务器在此，然后网络包通过这个 MAC 地址在服务器所在局域网内找到目标机器。</p>
</li>
</ol>
<p><!-- raw HTML omitted --></p>
<p><strong>服务端</strong></p>
<ol>
<li>目标服务器发现与网络请求包的 MAC 地址对上了，取下MAC头，将包传递给上一层网络层，发现 IP 也对上了，就取下 IP 头，然后交给传输层。在传输层里，对于收到的每一个包，都要回复包收到了，这个回复不是此次请求的响应，仅仅是回复包已收到而已，这个回复会沿着包的来路回去。</li>
<li>如果过了一段时间（超时时间），客户端还是没有收到来自服务器的回复，会重新发送这个包，直到收到回复为止。同样，这个重发也不是重新发起上面那个客户端请求，而是传输层将同一个请求反复重试，对用户来说，只有一次请求。</li>
<li>回到目标服务器，当网络包到达传输层后，TCP头中有一个服务器监听端口号，通过这个端口号，可以找到 网站正在监听的端口，即 Nginx 中配置的 443 端口，端口对上之后，取下 TCP 头，将网络包交给应用层，开始对 HTTP/HTTPS 请求进行处理。</li>
<li>如果是前端资源的话，直接通过 Nginx 进行响应，如果是 PHP 动态请求的话，再由 Nginx 将请求转发给后台运行的 PHP-FPM 进程进行处理。</li>
<li>当后台服务处理完成后，就会返回一个 HTTPS 的响应包，告知用户请求成功，并返回响应内容，同样这个网络响应包和请求包一样，自上而下经过层层打包，顺着来路经过层层「关卡」（网关），回到发起请求的客户端，然后再经过自下而上的处理，最终在客户端浏览器显示网站首页。</li>
</ol>
<p><img src="/img/network-protocol_3.png" alt=""></p>
<h3 id="从物理层到链路层">从物理层到链路层</h3>
<h4 id="mac地址">MAC地址</h4>
<p>MAC 地址用于识别数据链路中互连的节点，在使用网卡的情况下，MAC 地址一般在出厂的时候就被烧到 ROM 中，不可更改，而且全球唯一。</p>
<p>我们见到的 MAC 地址都是通过十六进制树来表示。在计算机内部，则是通过 48 位二进制数来表示，对应结构及区间含义如下：</p>
<p><!-- raw HTML omitted --></p>
<h4 id="数据帧格式">数据帧格式</h4>
<p><img src="/img/network-protocol_5.png" alt="">其中，有 6 个字节的目标 MAC 地址，6 个字节的源 MAC 地址，2 个字节的上层协议类型，剩下的是传输数据，对以太网来说，数据大小是 1500 字节，还有最后 4 位是帧检验序列（FCS），用于检测帧是否损坏。</p>
<h4 id="无线通信">无线通信</h4>
<p><!-- raw HTML omitted --></p>
<h3 id="常见命令">常见命令</h3>
<ul>
<li>
<p><code>PING</code></p>
<blockquote>
<p><code>ping</code> 是基于 ICMP（Internet Control Message Protocol）进行工作的。ICMP 的主要功能包括，确认 IP 包是否成功送到目标地址，通知在发送过程中 IP 包被废弃的具体原因，改善网络设置等。</p>
</blockquote>
<p><!-- raw HTML omitted --></p>
<ol>
<li>源主机首先会构建一个 ICMP 请求数据包，ICMP 数据包内包含多个字段。最重要的是两个，第一个是类型字段，对于请求数据包而言该字段为 <code>8</code>；另外一个是顺序号，主要用于区分连续 <code>ping</code> 的时候发出的多个数据包。每发出一个请求数据包，顺序号会自动加 <code>1</code></li>
<li>由 ICMP 协议将这个数据包连同地址 <code>220.181.57.216</code> 一起交给 IP 层。IP 层将以 <code>220.181.57.216</code> 作为目的地址，本机 IP 地址作为源地址，加上一些其他控制信息，构建一个 IP 数据包</li>
<li>加入 MAC 头，将它们传送出去</li>
<li>主机 B 收到数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议</li>
<li>主机 B 会构建一个 ICMP 应答包，应答数据包的类型字段为 <code>0</code>，顺序号为接收到的请求数据包中的顺序号，然后再发送出去给主机 A</li>
<li>在规定的时候间内，源主机如果没有接到 ICMP 的应答包，则说明目标主机不可达（类型 <code>3</code>）；如果接收到了 ICMP 应答包，则说明目标主机可达</li>
<li>为了安全起见，某些机器和设备是禁止被 <code>ping</code> 的，所以，<code>ping</code> 不通并不意味着一定是网络不通，对于禁止 <code>ping</code> 命令的主机，需要通过 <code>telnet</code> 命令测试是否可以连接。</li>
</ol>
</li>
<li>
<p><code>traceroute</code>：基于TTL（time to live）拿到了所有的路由器 IP（不显示指定 <code>TTL</code> 默认返回所有中间路由器 IP</p>
</li>
<li>
<p><code>ifconfig</code> 和 <code>ip addr</code></p>
<blockquote>
<p><code>ifconfig</code> 命令归属于 <code>net-tools</code> 工具集（停止维护）；<code>ip</code> 命令归属于 <code>iproute2</code> 工具集；</p>
<p><code>net-tools</code> 通过 <code>procfs(/proc)</code> 和 <code>ioctl</code> 系统调用去访问和改变内核网络配置； <code>iproute2</code> 则通过 <code>netlink</code> 套接字接口与内核通讯；</p>
</blockquote>
<ul>
<li><code>eth0</code> 和 <code>eth1</code> 都是网卡的名称（Ethernet），一张网卡用于内网通信，一张网卡用于外网通信</li>
<li><code>lo</code> 全称是 <code>loopback</code>，又称环回接口，往往会被分配到 <code>127.0.0.1</code> 这个地址</li>
</ul>
</li>
<li>
<p><code>networksetup -listallhardwareports</code>：列出所有硬件端口</p>
</li>
</ul>
<h2 id="网络层协议">网络层协议</h2>
<h3 id="ip协议">IP协议</h3>
<ul>
<li>
<p>**IP地址：**MAC 地址用于标识同一链路上的不同计算机，而网络层用于表示地址信息的是 IP 地址</p>
<ul>
<li>
<p>**私网IP：**局域网通信</p>
<blockquote>
<p>通过 NAT 路由器做 IP 地址转化时将本地网络中不同主机转化为同一个 IP 地址，而将端口号转化为不同端口号，以示区别。（使用 TCP 或 UDP 的通信中，只有当目标地址、源地址、目标端口、源端口以及协议类型（TCP或UDP）五项内容都一致时才被认为是同一个通信连接）</p>
</blockquote>
<p><!-- raw HTML omitted --></p>
</li>
<li>
<p>**公网IP：**要在整个互联网内保持唯一</p>
</li>
</ul>
</li>
<li>
<p><strong>IP格式：</strong></p>
<ul>
<li>**IPv4 ：**由 32 位二进制数字表示，为了方便人类识别，通常将其按照 8 位一组，分为 4 组，每组用 <code>.</code> 分隔，并将每组内的二进制数转化为十进制数</li>
<li><strong>IPv6</strong>：由 128 位二进制数字表示，一般写成 8 个 16 位字节</li>
</ul>
</li>
<li>
<p>**IP地址组成：**IP 地址由网络标识（网络地址）和主机标识（主机地址）两部分组成。</p>
<ul>
<li>**网络标识（网络地址）：**标识节点所属的数据链路，一般不同的局域网之间网络地址必须不同，而同一个局域网内的主机必须有相同的网络地址</li>
<li>**主机标识（主机地址）：**标识同一个局域网内的不同主机，它们的主机地址不能重复</li>
</ul>
</li>
<li>
<p><strong>IP地址分类：</strong></p>
<p><img src="/img/network-protocol_8.png" alt=""></p>
<ul>
<li>**A 类地址：**以0开头，第 2-8 位是网络地址，后24位是主机地址，<code>0.0.0.0~127.0.0.0</code> 是 A 类的网络地址，可容纳 16777214（2^24^-2） 个主机地址</li>
<li>**B 类地址：**以10开头，第 3-16 位是网络地址，后 16 位是主机地址，<code>128.0.0.0~191.255.0.0</code> 是 B 类的网络地址，可容纳 65534(2^16^-2) 个主机地址</li>
<li>**C 类地址：**以110开头，第 4-24 位是网络地址，后 8 位是主机地址，<code>192.168.0.0~239.255.255.0</code> 是 C 类的网络地址，可容纳 254(28-2) 个主机地址</li>
<li>**D 类地址：**以 1110 开头，第 1-32 位是网络地址，没有主机地址，<code>224.0.0.0~239.255.255.255</code> 是 D 类的网络地址，常用于多播</li>
<li><strong>减2</strong>是因为要去掉<strong>全部为0</strong>（IP 地址不可获知）和<strong>全部为1</strong>（广播地址）的情况</li>
</ul>
</li>
<li>
<p><strong>子网掩码：</strong></p>
<ul>
<li>**目的：**将子网网络地址细分为比 A、B、C 类粒度更小的网络</li>
<li>**方法：**将原来的 A、B、C 类主机地址的一部分也作为网络地址，从而让 IP 地址的网络地址和主机地址不再受限于 IP 地址的分类，将原有网络划分为更多的子网</li>
<li>**格式：**子网掩码和 IP 地址一样也是由 32 位二进制数表示，格式和 IP 地址类似，只不过其对应 IP 地址网络地址部分的位都是 1，主机地址部分的位都是 0</li>
</ul>
</li>
<li>
<p><strong>其它：</strong></p>
<ul>
<li>广播地址：用于在同一个局域网中相互连接的主机之间发送数据（IP 地址中的主机地址部分全部设置为 <code>1</code>）</li>
<li>环回地址：同一台计算机内部的程序之间进行网络通信时所使用的默认地址（<code>127.0.0.1</code> 或 <code>localhost</code>）</li>
</ul>
</li>
<li>
<p>**路由控制：**为了将数据包发送给目标主机，所有主机和路由器都维护着一张路由控制表，该表记录 IP 数据在下一步应该发给哪个路由器，IP 数据包将根据这个路由表在各个数据链路上传输</p>
<ul>
<li>**静态路由控制：**管理员手动设置</li>
<li>**动态路由控制（DHCP）：**路由器根据与其他路由器相互交换信息时自动刷新
<ol>
<li>先在局域网内假设一台 DHCP 服务器（一般由路由器充当），然后将 DHCP 所要分配的 IP 地址设置到服务器上，此外，还需要将子网掩码、路由控制、DNS 服务器地址等信息也设置到服务器上</li>
<li>新加入的机器或设备（DHCP 客户端）使用 IP 地址 <code>0.0.0.0</code> （此时还没有分配IP地址）发送了一个广播包，目标 IP 地址为 <code>255.255.255.255</code>（广播地址）。广播包里包含了该机器的 MAC 地址，请求 DHCP 服务器为其分配 IP 地址</li>
<li>DHCP 服务器收到广播后会通知新加入机器可用的网络设置（通过 MAC 地址唯一确定），包括 IP 地址、子网掩码、网关等信息，这个通知仍然以广播形式发送，因为这个时候新机器还没有分配 IP 地址。此时，DHCP 就已经将这个 IP 地址标记为已分配，其它机器将无法获取到这个 IP</li>
<li>新机器拿到 IP 地址后，会给 DHCP 服务器发送一个 DHCP 请求，表示接受这个 DHCP 服务器分配的 IP 地址，此时还是使用广播包，DHCP 服务器收到请求后，会返回给新机器一个 DHCP ACK 消息包，新机器收到消息后，由操作系统完成 IP 地址分配</li>
<li>当新机器离开这个网段时，会发送 DHCP 解除包让这个 IP 地址回到 DHCP IP 地址池，以便其他新接入设备使用</li>
</ol>
</li>
</ul>
</li>
<li>
<p><strong>IP头：</strong></p>
<p><!-- raw HTML omitted --></p>
<ul>
<li>版本：用于标识 IP 首部的版本号，IPv4 的版本号即4，关于 IP 首部的版本信息可以参考这里：https://www.iana.org/assignments/version-numbers/version-numbers.xhtml。</li>
<li>首部长度：IP首部的大小，单位为字节。</li>
<li>区分服务（TOS）：用来表示服务质量，IP 协议本身是一种尽力服务的协议，无法保证通信质量，但是近年来随着音视频服务对实时性要求的提高，在使用 IP 通信过程当中保证服务质量的技术也有了蓬勃发展。DSCP 字段用于在通过 DiffServ 控制网络质量的时候设置包的优先级；ECN 则主要用于网络通信中的显式拥塞通知。</li>
<li>总长度：IP首部与数据部分结合起来的总字节数，最大长度是65535。</li>
<li>标识：用于 IP 包分片重组，不同分片标识值不同。</li>
<li>标志：表示包被分片的相关信息。</li>
<li>片偏移：用来标识被分片的每一个分段相对于原始数据的位置。以上三个字段用于 IP 包的分片与重组。</li>
<li>生存时间：最初设计为网络包的有效时间，实际用于可以中转多少个路由器，每经过一个路由器，TTL值减1，直到为0则丢弃该包。</li>
<li>协议：标识 IP 首部的上一层首部隶属于哪个协议，比如 TCP 或 UDP，具体支持的协议信息请参考这里：https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml。</li>
<li>首部校验和：只校验数据报的首部，不校验数据部分，主要用来确保 IP 数据报不被破坏。</li>
<li>源地址：发送端 IP 地址。</li>
<li>目标地址：接收端 IP 地址。</li>
<li>可选项：通常在实验或诊断时才使用。</li>
<li>填充：在有可选项的情况下，首部长度可能不是32位的整数倍，通过向该字段填充0，将其调整为32位整数倍，以方便计算机进行处理。</li>
<li>数据：传输的具体数据（并不是首部的一部分）。</li>
</ul>
</li>
<li>
<p><strong>IP与域名之间的映射：</strong></p>
<blockquote>
<p>在 DNS 诞生之前，每个主机存储一个 <code>hosts</code> 文件来进行对IP的映射</p>
</blockquote>
<ul>
<li>根 DNS 服务器：返回顶级域 DNS 服务器的 IP 地址（.）</li>
<li>顶级域 DNS 服务器：返回权威 DNS 服务器的 IP 地址（com  org  io  net  edu &hellip;）</li>
<li>权威 DNS 服务器：返回固有域名对应主机的 IP 地址（alibaba  google  &hellip;）</li>
<li>DNS 解析器：进行 DNS 查询的主机或软件</li>
</ul>
</li>
<li>
<p><strong>IP与MAC之间的映射：</strong></p>
<blockquote>
<p>通过 IP 地址获取 MAC 地址就需要借助 ARP，ARP 是一种地址解析协议，以目标 IP 地址为条件，来定位下一个应该接收数据包的网络设备的 MAC 地址，如果对应 MAC 地址不存在，意味着目标主机不在该网段内，接着通过 ARP 查找下一跳路由器的 MAC 地址</p>
</blockquote>
<ol>
<li>
<p>主机 <code>A</code> 为了获取主机 <code>B</code> 的 MAC 地址，首先要通过广播发送一个 ARP 请求包，这个包中包含了想要了解其 MAC 地址的对应主机 IP 地址（即主机 <code>B</code> 的 IP 地址）</p>
</li>
<li>
<p>由于广播包可以被同一链路上的所有主机或路由器接收，因此 ARP 的请求包就会被这个链路上的所有主机和路由器进行解析，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，这个节点就将自己的 MAC 地址塞入 ARP 响应包返回给主机 <code>A</code></p>
<blockquote>
<p>为了降低网络流量，提高通信效率，IP 地址与 MAC 地址映射关系表即 ARP 缓存表会被缓存起来</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<h3 id="路由协议">路由协议</h3>
<p>制定自己的路由策略，并以此为准在一个或多个网络群体中采用的较小单位叫做自治系统（AS：Autonomous System）。</p>
<p>自治系统内部动态路由采用的协议是内部网关协议（Interior Gateway Protocol），简称 IGP。而自治系统之间的路由控制采用的是外部网关协议（Exterior Gateway Protocol），简称 EGP。</p>
<p><img src="/img/network-protocol_11.png" alt=""></p>
<ul>
<li>**RIP：**Routing Information Protocol，路由信息协议
<ul>
<li>RIP 将路由控制信息定期（30秒）向全网广播。如果没有收到路由控制信息，连接就会被断开，不过这有可能是丢包导致的，所以 RIP 规定等待 5 次。</li>
<li>RIP 基于距离向量算法决定路径。距离的单位为跳数（Metrics），跳数是指所经过路由器的个数。RIP希望尽可能<strong>少经过路由器</strong>（并不一定最优）将数据包转发到目标 IP 地址。</li>
</ul>
</li>
<li>**OSPF：**Open Shortest Path First，开放式最短路径优先
<ul>
<li>OSPF 支持子网掩码，为了减少网络流量，还引入了「区域」这一概念，将一个自治网络划分为若干个更小的范围</li>
<li>在 OSPF 中，路由器之间交换链路状态生成网络拓扑信息，然后再根据这个拓扑信息生成路由控制表（选择<strong>权重最小</strong>的路径作为最终路由）</li>
</ul>
</li>
<li>**BGP：**Border Gateway Protocol，边界网关协议
<ul>
<li>BGP 的路由控制表最终由网络地址和下一站的路由器组来表示，不过它会根据所要经过的 AS 个数进行路由控制。</li>
<li>ISP、区域网络会将每个网络区域编配成一个个自治系统进行管理，它们为每个自治系统分配一个 16 比特的 AS 编号。BGP 就是根据这个编号进行相应的路由控制。</li>
<li>BGP 协议使用的算法是<strong>路径向量算法</strong>，它是距离向量算法的升级版，解决了坏消息传递慢（某个路由器故障系统感知慢）的问题，将单个自治系统看作一个整体，不区分自治系统内部的路由器，因此规模有限。</li>
</ul>
</li>
</ul>
<p>动态路由离不开相关的动态路由协议，而这些路由协议算法又可以转化为从图中找到最短路径的问题（计算机网络拓扑可以看作是图结构）。</p>
<ul>
<li>**距离向量算法：**基于弗洛伊德算法，是一种根据距离和方向（向量）决定目标网络或目标主机位置的算法
<ol>
<li>每个路由器都保存一个路由表，包含多行，每行对应网络中的一个路由器，每一行包含两部分信息，一个是要到目标路由器，另一个是到目标路由器的距离。</li>
<li>每个路由器都知道自己和邻居之间的距离，每过几秒，每个路由器都将自己所知的到达所有的路由器的距离告知邻居，每个路由器也能从邻居那里得到相似的信息。</li>
<li>每个路由器根据新收集的信息，计算和其他路由器的距离，比如自己的一个邻居距离目标路由器的距离是 <code>M</code>，而自己距离邻居是 <code>x</code>，则自己距离目标路由器是 <code>x+M</code>。</li>
</ol>
</li>
<li>**链路状态算法：**基于迪杰斯特拉算法，是一种路由器在了解网络整体连接状态的基础上生成路由控制表的算法
<ol>
<li>当一个路由器启动的时候，首先是发现邻居，向邻居发送消息，邻居都回复。</li>
<li>计算和邻居的距离，发送一个 <code>echo</code>，要求马上返回，除以二就是距离。然后将自己和邻居之间的链路状态包广播出去，发送到整个网络的每个路由器。</li>
<li>这样每个路由器都能够收到它和邻居之间的关系的信息。因而，每个路由器都能在自己本地构建一个完整的图，然后针对这个图使用迪杰斯特拉算法，找到两点之间的最短路径。</li>
</ol>
</li>
</ul>
<h2 id="传输层协议">传输层协议</h2>
<h3 id="tcp协议">TCP协议</h3>
<p>TCP 提供面向连接的可靠性传输。</p>
<h4 id="格式"><strong>格式</strong></h4>
<p><!-- raw HTML omitted --></p>
<blockquote>
<p>TCP 没有表示包长度和数据长度的字段，可由 IP 层获取 TCP 的包长度，由 TCP 的包长可获知数据的长度</p>
</blockquote>
<ul>
<li>源端口号：发送端端口号</li>
<li>目标端口号：接收端端口号</li>
<li>序列号：发送数据的位置，每发送一次数据，就累加一次该数据字节数的大小，序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为初始值，通过 SYN 包发送给接收端主机。此外，建立连接和断开连接时虽然不传输数据，但也会作为一个字节增加对应的序列号</li>
<li>确认应答号：下一次应该接收到的数据的序列号，实际上，它是指已经收到确认应答号减一为止的数据</li>
<li>数据偏移：TCP 所传输的数据部分应该从 TCP 包的哪个位置开始计算，也可以将其看作 TCP 包的长度，单位为4字节</li>
<li>保留：为了以后扩展用</li>
<li>控制位：字段长8位，每一位从左到右分别是CWR、ECE、URG、ACK、PSH、RST、SYN、FIN
<ul>
<li>CWR（Congestion Window Reduced）：与后面的ECE都是用于IP首部的ECN字段，为1时通知对方已将拥塞窗口缩小</li>
<li>ECE（ECN-Echo）：置为1时通知通信对方，从对方到这边的网络有拥堵</li>
<li>URG（Urgent Flag）：该位为1时，表示包中有需要紧急处理的数据</li>
<li>ACK（Acknowledgement Flag）：该位为1时，确认应答的字段变为有效</li>
<li>PSH（Push Flag）：该位为1时，表示需要将收到的数据立即传给上层应用协议，为0时则表示先不上传而是缓存起来</li>
<li>RST（Reset Flag）：该位为1时，表示TCP连接中出现异常必须强制断开连接</li>
<li>SYN（Synchronize Flag）：该位为1时，表示希望建立连接，并在序列号字段进行序列号初始值的设定</li>
<li>FIN（Fin Flag）：该位为1时，表示今后不会再有数据发送，希望断开连接</li>
</ul>
</li>
<li>窗口大小：用于通知从相同 TCP 首部的确认应答号所指位置开始能够接收的数据大小
<ul>
<li>TCP 在传输大量数据时，是以 MSS （Maximum Segment Size）的大小将数据分割发送，<strong>包往返的时间越长通信性能就越低</strong></li>
<li>窗口的大小就是指无需等待确认应答而可以继续发送数据的最大值</li>
</ul>
</li>
<li>校验和：TCP和UDP一样，在计算校验和时使用伪首部，主要用于检查路由器内存故障或程序漏洞导致的数据破坏</li>
<li>紧急指针：只有在 URG 控制位为1时有效，该字段数值表示本报文段中紧急数据的指针</li>
<li>选项：用于提高 TCP 的传输性能</li>
<li>填充：选项长度不足32位整数倍时将其补齐到32位整数倍</li>
</ul>
<h4 id="三次握手">三次握手</h4>
<p>三次握手的目的是为了确保对连接双方来说，链路都是通的。还为了沟通一件事情，就是 TCP 包序列号的问题。每个连接都要有不同的序列号，这个序列号的起始序号是随着时间变化的</p>
<p>建立了连接之后，为了维护这个连接，双方都要维护一个状态机，在连接建立的过程中，双方的状态变化时序图如下：</p>
<p><!-- raw HTML omitted --></p>
<ol>
<li>客户端和服务端都处于 <code>CLOSED</code> 状态</li>
<li>服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</li>
<li>客户端主动发起连接 <code>SYN</code>（连接请求），之后处于 <code>SYN-SENT</code> 状态</li>
<li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> （确认应答）客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态</li>
<li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送 <code>ACK</code> 的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态</li>
<li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态</li>
</ol>
<h4 id="流量控制">流量控制</h4>
<p>发送端会根据自己的实际情况发送数据，但是，接收端可能收到的是一个毫无关系的数据包又可能会在处理其它问题上耗费一些时间，甚至在高负荷的情况下无法接收任何数据。如此一来，如果接收端将本该接收的数据丢弃的话，就又会触发重发机制，从而导致网络流量的无端浪费。为了防止这种现象的发生，TCP 提供一种机制可以让发送端根据接收端的实际接收能力控制发送的数据量。这就是所谓的流量控制。</p>
<p>它的具体操作是，接收端主机向发送端主机通知自己可以接收数据的大小，于是发送端会发送不超过这个限度的数据，该大小限制被称作窗口大小。</p>
<p>TCP 首部中，专门有一个字段用来通知窗口大小，接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段值越大，说明网络的吞吐量越高。</p>
<p>不过，接收端的这个缓冲区一旦面临数据溢出风险，窗口大小的值也会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。也就是说，发送端会根据接收端的指示，对发送数据的量进行控制。这个形成了一个完整的 TCP 流量控制。</p>
<h4 id="拥塞控制">拥塞控制</h4>
<p>有了 TCP 的窗口控制，收发主机之间即使不再以一个数据段为单位发送确认应答，也能连续发送大量数据包。然而，如果在通信一开始就发送大量数据，容易引发其它问题。一般来说，计算机网络都处在一个共享的环境，因此，也有可能因为其它主机之间的通信导致网络拥堵，在网络拥堵时，如果发送一个较大量的数据，极有可能导致整个网络的瘫痪。</p>
<p>TCP 为了防止该问题的出现，在通信一开始就会通过一个叫做慢启动的算法得出的值，对发送数据量进行控制。</p>
<p>首先，为了在发送端调节所要发送数据的量，定义了一个叫做「拥塞窗口」的概念，于是在慢启动的时候，将这个拥塞窗口的大小设置为1个数据段（1MSS）发送数据，之后每收到一个确认应答（ACK），就将拥塞窗口的值加1，在发送数据包时，将拥塞窗口的大小与接收端主机通知的窗口大小做比较，然后按照它们当中较小的那个值，发送比它还要小的数据量。</p>
<p>有了这种机制，就可以有效减少通信开始时连续发包导致的网络拥堵。此外，为了防止超时重发时，随着包往返导致的拥塞窗口快速增长（指数增长），引入了慢启动阀值的概念，只要拥塞窗口的大小超过这个阀值，每收到一次确认应答时，只允许以下面这种方式放大拥塞窗口：</p>
<p><img src="/img/network-protocol_15.png" alt=""></p>
<p>拥塞窗口越大，确认应答的数目也会增加，不过每收到一个确认应答，其涨幅也会逐渐减小，甚至小过比一个数据段还要小的字节数。</p>
<p>需要注意的是，TCP 开始通信时，并没有设置慢启动阀值，只有超时重发时才会设置该值，初始值为当时拥塞窗口的一半。</p>
<p>总结起来，用于流量控制的滑动窗口是为了防止把接收端缓存塞满，用于拥塞控制的拥塞窗口是为了防止把网络塞满，导致网络拥塞。TCP 的拥塞控制主要来避免两种现象，包丢失和超时重发。一旦出现了这些现象就说明，发送速度太快了，要慢一点。</p>
<h3 id="udp协议">UDP协议</h3>
<p>UDP 提供面向无连接的通信服务，是不具有可靠性的数据报协议。</p>
<p><strong>优缺点</strong></p>
<ul>
<li>可以确保发送消息的大小，但不能保证消息一定会到达，传输途中如果出现丢包，UDP 不负责进行重发</li>
<li>当包的到达顺序错乱时，UDP 也没有纠正功能</li>
<li>出现网络拥堵，UDP 也无法进行流量控制等避免避免网络拥塞的行为</li>
<li>**优：**可以随时发送数据，本身的处理逻辑简单高效</li>
</ul>
<p><strong>应用场景</strong></p>
<ul>
<li>包总量较少（DNS、DHCP）</li>
<li>视频、音频等多媒体即时通信（少量的丢包不影响通信质量）</li>
<li>广播通信（广播、多播）</li>
</ul>
<p><strong>结构</strong></p>
<p><!-- raw HTML omitted --></p>
<ul>
<li>源端口号：发送端端口号，该字段有可能为空（不需要返回的通信）</li>
<li>目标端口号：接收端端口号</li>
<li>包长度：UDP 首部的长度跟数据的长度之和</li>
<li>校验和：为了提供可靠的 UDP 首部和数据而设计，不一定会用到</li>
</ul>
<h3 id="socket编程">SOCKET编程</h3>
<p>位于应用层的应用程序在基于 TCP 协议或 UDP 协议进行通信时，需要用到操作系统提供的类库，这种类库一般称为 API（Application Programming Interface，应用编程接口）。</p>
<p>使用 TCP 或 UDP 时，又会广泛使用到 Socket（套接字）API，Socket 原本是由 BSD UNIX 开发的，但是后来被移植到 Windows 的 Winsock 以及嵌入式系统中。应用程序利用 Socket，可以设置对端的 IP 地址、端口号，并实现数据的接收和发送。</p>
<h4 id="tcp套接字">TCP套接字</h4>
<p><!-- raw HTML omitted --></p>
<ol>
<li>
<p>TCP 的服务端要先监听一个端口，一般是先调用 <code>bind</code> 函数，给<strong>这个 Socket</strong> 赋予一个 IP 地址和端口。</p>
</li>
<li>
<p>调用 <code>listen</code> 函数进行监听（之后服务端就进入<code>listen</code> 状态，客户端就可以发起连接了）</p>
<blockquote>
<p>在操作系统内核中，为每个 Socket 维护两个队列</p>
<p>一个是已经建立了连接的队列，处于 <code>established</code> 状态</p>
<p>一个是还没有完全建立连接的队列，处于 <code>syn_rcv</code> 的状态</p>
</blockquote>
</li>
<li>
<p>服务端调用 <code>accept</code> 函数，拿出一个已经完成的连接进行处理。如果还没有完成，就要等着。</p>
</li>
<li>
<p>在服务端等待的时候，客户端可以通过 <code>connect</code> 函数发起连接，发起三次握手，一旦握手成功，服务端的 <code>accept</code> 就会返回<strong>另一个 Socket</strong> 用于传输数据。</p>
</li>
<li>
<p>连接建立成功之后，双方开始通过 <code>read</code> 和 <code>write</code> 函数来读写数据，就像往一个文件流里面写东西一样。</p>
</li>
</ol>
<h4 id="udp套接字">UDP套接字</h4>
<p>因为 UDP 通信无需建立连接，所以不需要三次握手，也就不需要调用 <code>listen</code> 和 <code>connect</code> 函数，但是，UDP 的的交互仍然需要 IP 和端口号，因而也需要 <code>bind</code>。UDP 是没有维护连接状态的，因而不需要每对连接建立一组 Socket，而是只要有一个 Socket，就能够和多个客户端通信。也正是因为没有连接状态，每次通信的时候，调用 <code>sendto</code> 和 <code>recvfrom</code>，都可以传入 IP 地址和端口。</p>
<h4 id="多并发">多并发</h4>
<p>Web 请求一般都是 HTTP 请求，而 HTTP 协议又是基于 TCP 的，所以，我们主要探讨如何让服务器同时处理更多 TCP 连接请求。</p>
<p>服务器通常固定在某个本地端口上监听，等待客户端的连接请求。服务器端 TCP 连接四元组中只有对端 IP 和对端端口（即客户端IP和端口）是可变的，因此，最大 TCP 连接数 = 客户端 IP 数 × 客户端端口数。对 IPv4，客户端的 IP 数最多为 2 的 32 次方，客户端的端口数最多为 2 的 16 次方，也就是服务端单机最大 TCP 连接数，约为 2 的 48 次方。</p>
<p>当然，服务端最大并发 TCP 连接数远不能达到理论上限。首先主要是文件描述符限制，按照前面介绍的原理，Socket 都是文件，所以首先要通过 <code>ulimit</code> 配置文件描述符的数目；另一个限制是内存，按上面的数据结构，每个 TCP 连接都要占用一定内存，操作系统是有限的。</p>
<p>常用解决方案：</p>
<ul>
<li><strong>多进程：</strong> 当有新的请求进来，fork出一个子进程，让子进程处理该请求，提高并发量（解决不了C10K）</li>
<li><strong>多线程：</strong> 进程开销太大，线程则轻量级的多，所以我们还可以通过在进程中创建新的线程来处理请求（但也解决不了C10K）</li>
<li><strong>多路IO复用：</strong> 所谓多路 IO 复用可以简单理解为一个线程维护多个 Socket（前面多进程或多线程都是一个进程或线程维护一个 Socket），有两种实现方式：轮询和事件通知
<ul>
<li><strong>轮询：</strong> 因为 Socket 在 Linux 系统中以文件描述符形式存在，所以我们把一个线程维护的所有 Socket 叫做<strong>文件描述符集合</strong>，所谓轮询就是调用内核的 <code>select</code> 函数<strong>监听文件描述符集合是否有变化</strong>，一旦有变化，就会依次查看每个文件描述符，对那些发生变化的文件描述符进行读写操作，然后再调用 <code>select</code> 函数监听下一轮的变化。</li>
<li><strong>事件通知：</strong> 就是某个文件描述符发生变化，调用 <code>epoll</code> 函数主动通知。这种方式使得监听的 Socket 数据增加的时候，效率不会大幅度降低，能够同时监听的 Socket 的数目也非常多。上限就为系统定义的、进程打开的最大文件描述符个数。</li>
</ul>
</li>
</ul>
<h2 id="应用层协议">应用层协议</h2>
<h3 id="远程登录协议">远程登录协议</h3>
<ul>
<li>
<p><strong>TELNET：</strong> 基于 TCP 连接将向主机发送文字命令并在主机上执行，常用于登录路由器或高性能交换机等网络设备进行相应的设置</p>
<ul>
<li>命令格式：<code>telnet 主机名(或IP) TCP端口号</code></li>
</ul>
</li>
<li>
<p><strong>SSH：</strong> （Secure Shell ）可以加密通信内容，是加密的远程登录协议，通过在网络中建立安全隧道来实现 SSH 客户端与服务器之间的连接，可以在不安全的网络中为网络服务提供安全的传输环境</p>
<ul>
<li>
<p>命令格式：<code>ssh &lt;用户名&gt;@&lt;主机名或IP地址&gt;</code></p>
</li>
<li>
<p>原理：</p>
<ol>
<li>远程主机收到用户的登录请求，把自己的公钥发给用户；</li>
<li>用户使用这个公钥，将登录密码加密后，发送回来；</li>
<li>远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。</li>
</ol>
</li>
<li>
<p>中间人攻击：</p>
<ul>
<li>
<p>攻击者插在用户与远程主机之间，用伪造的公钥，获取用户的登录密码，再用这个密码登录远程主机</p>
</li>
<li>
<p>应对：在通过 SSH 首次进行远程登录的时候，系统会要求你比对返回的公钥是否与目标服务器上的公钥信息一致</p>
<blockquote>
<p><code>ssh-keyscan -t ECDSA -p 22 laravelacademy.org</code>  获取服务器公钥</p>
<p><code>ssh-keygen -E sha256 -lf ~/.ssh/known_hosts</code>  计算公钥的指纹</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>使用公钥登录：户将自己的公钥储存在远程主机上。登录的时候，远程主机会向用户发送一段随机字符串，用户用自己的私钥加密后，再发回来。远程主机用事先储存的公钥进行解密，如果成功，就证明用户是可信的，直接允许登录，不再要求密码。</p>
</li>
</ul>
</li>
</ul>
<h3 id="文件传输协议">文件传输协议</h3>
<p>FTP 的英文全称是 File Transfer Protocol，意为文件传输协议，也就是在两个相连的计算机（通常是本地主机与服务器）之间进行文件传输的协议。</p>
<p><strong>底层原理：</strong></p>
<p>FTP 使用两个 TCP 连接实现文件传输：一个 TCP 连接用于控制，另一个 TCP 连接用于数据传输。</p>
<p>控制主要包含用户登录和验证、发送文件的名称、发送方式设置等。利用这个连接，可以通过 ASCII 码字符串发送请求和接收应答。但在这个连接上无法发送数据，只能通过另一个专门的 TCP 连接实现数据传输。</p>
<p>FTP 控制用的连接使用的是 21 号端口，该端口进行文件 GET（RETR）、PUT（STOR）、以及文件预览（LIST）等操作时，每次都会建立一个用于数据传输的 TCP 连接。数据传输完毕后，传输数据的这个连接被断开，然后在控制用的连接上继续进行命令或应答的处理。</p>
<p>控制用的连接，在用户要求断开之前会一直保持连接状态，不过，绝大多数 FTP 服务器都会对长时间没有任何新命令输入的用户的连接强制断开。</p>
<p>数据传输用的连接通常使用端口 20，不过可以用 PORT 命令修改为其它值。</p>
<p><strong>文件传输：</strong></p>
<p>FTP 在传输过程中不会对信息进行加密，都是明文传输，因而有被窃听和侵入的风险，由此衍生出了安全的文件传输协议 SFTP（SSH File Transfer Protocol），它会使用 SSH 协议进行身份验证并建立安全连接，所以推荐在日常使用时优先考虑 SFTP。</p>
<h3 id="电子邮件协议">电子邮件协议</h3>
<p>SMTP（Simple Mail Transfer Protocol，简单邮件传输协议），SMTP 为了实现高效发送邮件，在传输层上使用了 TCP 协议。</p>
<p>早期的电子邮件就是通过通信双方建立 TCP 连接实现的，发送端写好邮件后，会保存到硬盘，然后通过建立 TCP 连接将邮件发送到对方的硬盘，发送结束后从发送端硬盘删除该邮件，如果接收方机器没开或者断电，需要过一段时间重发。</p>
<p>显然，这种方式有很大的弊端，需要通信双方都开机的情况下才能发送邮件，像中美两个国家白天和夜晚是颠倒的，则永远无法通信。</p>
<p>为此，在技术上改变了以往直接在发送端和接收端主机之间建立 TCP 连接的机制，而引入了一种会直连电源的邮件服务器，发送端和接收端通过邮件服务器进行邮件的收发。接收端从邮件服务器接收邮件使用 POP3 或 IMAP 协议。</p>
<ul>
<li>
<p><strong>邮箱地址：</strong> <code>用户名@邮件服务器域名</code></p>
<ul>
<li>DNS 中注册了邮箱地址及其作为发送地址时对应的邮件服务器的域名，这些映射信息被称作 MX 记录</li>
</ul>
</li>
<li>
<p><strong>数据格式：</strong></p>
<p><img src="/img/network-protocol_17.png" alt=""></p>
</li>
<li>
<p><strong>发送协议：</strong></p>
<ul>
<li><strong>SMTP</strong> 是发送电子邮件的协议，使用的是 TCP 的 25 号端口
<ul>
<li>它支持的是发送端主机的行为，而不是根据接收端的请求进行发送的行为，因此无法解决用户一开机就能接收到邮件</li>
</ul>
</li>
<li><strong>POP</strong>（Post Office Protocol，即邮局协议）协议，该协议是一种用于接收电子邮件的协议，现在用的是第三版，所以我们经常会看到它的简称 <strong>POP3</strong>
<ul>
<li>发送端的邮件根据 SMTP 协议将被转发给一直处于插电状态的 POP 服务器，客户端再根据 POP 协议从 POP 服务器接收对方放过来的邮件。在这个过程中，也要做用户验证。</li>
<li>也是在客户端与服务器之间通过建立一个 TCP 连接完成相应操作，POP 服务端监听端口是 110</li>
</ul>
</li>
<li><strong>IMAP</strong> （Internet Message Access Protocol，互联网邮件访问协议）也是接收电子邮件的协议
<ul>
<li>在 POP 中邮件由客户端管理，而在 IMAP 中邮件由服务器管理。因此，在使用 IMAP 时，可以不必从服务器下载所有邮件就可以阅读</li>
<li>IMAP 在服务器上对「已读/未读」信息和邮件进行分类管理，因此，即使在不同的计算机上打开邮箱，也能保持同步</li>
<li>IMAP 服务端监听端口一般是 143</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="http协议">HTTP协议</h2>
<h3 id="报文">报文</h3>
<ul>
<li>
<p>**方法（method）：**客户端希望服务器对资源执行的动作</p>
<ul>
<li><strong>GET：</strong> 用于从服务器上获取指定的 URL 资源</li>
<li><strong>HEAD：</strong> 和 GET 方法类似，但只返回 HTTP 首部，不返回报文主体部分，通常用于确认 URL 的有效性及资源更新的日期时间等</li>
<li><strong>POST：</strong> 用来向服务器发送数据</li>
<li><strong>PUT：</strong> 初衷是用来传输文件，要求在报文的主体中包含文件内容，然后保存到请求 URI 指定的位置，不带验证机制，存在安全性问题</li>
<li><strong>DELETE：</strong> 设计的初衷是用来删除文件，是与 PUT 请求相对的方法，DELETE 方法按请求 URI 删除指定的资源</li>
<li><strong>OPTIONS：</strong> 查询针对请求 URL 指定的资源支持的所有 HTTP 方法。Nginx 默认也不支持对资源发起 OPTIONS 请求</li>
<li><strong>TRACE：</strong> 主要用于 HTTP 通信的诊断和调试（容易引发 XST（Cross-Site Tracing，跨站追踪）攻击）</li>
</ul>
</li>
<li>
<p><strong>请求 URL（request-URL）</strong>：命名了所请求资源，或者 URL 路径组成的完整 URL</p>
</li>
<li>
<p>**版本（version）：**HTTP 版本，目前主流版本是 1.1；</p>
</li>
<li>
<p>**状态码（status-code）：**三个数字，描述了请求过程所发生的情况</p>
<ul>
<li>**1XX：**信息性状态码
<ul>
<li>100：说明收到请求的初始部分，请客户端继续，比如客户端要发送一个请求实体给服务器，但想在发送之前查看下服务器是否会接收这个实体；</li>
<li>101：说明服务器正在根据客户端的指定，将协议切换成 Upgrade 首部所列的协议。</li>
</ul>
</li>
<li>**2XX：**成功状态码
<ul>
<li>200：表明从客户端发来的请求在服务器端被正常处理了；</li>
<li>201：用于创建服务器对象的请求（如 PUT 请求）；</li>
<li>202：请求已被接收，但服务器还未对其执行任何动作；</li>
<li>203：表明实体部分包含的信息不是来自源端服务器，而是来自资源的一份副本；</li>
<li>204：该状态码代表服务器接收的请求已经成功处理，但在返回的响应报文中不含实体的主体部分；</li>
<li>205：负责告知浏览器清除当前页面中的所有 HTML 表单元素；</li>
<li>206：该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求，响应报文中由 Content-Range 指定范围的实体内容。</li>
</ul>
</li>
<li>**3XX：**重定向状态码
<ul>
<li>300：客户端请求一个实际指向多个资源的 URL 时返回这个状态码；</li>
<li>301：永久性重定向</li>
<li>302：临时性重定向</li>
<li>303：303 状态码和 302 状态码有着相同的功能，但 303 状态码明确表示客户端应当采用 GET 方法获取资源，这点和 302 状态码有所区别；</li>
<li>304：该状态码表示客户端发送附带条件的请求（If-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since）时，服务器端允许请求访问资源，但未满足条件的情况下，304 状态码返回时，不包含任何响应的主体部分，常用做客户端缓存。304 虽然被划分在 3XX 类别中，但是与重定向没有任何关系；</li>
<li>305：用来说明必须通过一个代理来访问资源，代理的位置由 Location 首部指定；</li>
<li>307：临时重定向，该状态码与 302 有着相同的含义，尽管 302 标准禁止 POST 变成 GET，但实际使用时大家都不遵守。307 会遵照浏览器标准，不会从 POST 变成 GET，但是对于处理响应时的行为，每种浏览器都有可能出现不同的情况。</li>
</ul>
</li>
<li>**4XX：**客户端错误状态码
<ul>
<li>400：该状态码表示请求报文中存在语法错误，当错误发生时，需修改请求的内容后再次发送请求；</li>
<li>401：该状态码表示发送的请求需要有通过 HTTP 认证的认证信息，另外若之前已进行过1次请求，则表示用户认证失败；</li>
<li>402：该状态码暂时还未启用；</li>
<li>403：该状态码表明对请求资源的访问被服务器拒绝了，服务器端没有必要给出拒绝的详细理由，但如果想做说明的话，可以在实体的主体部分对原因进行描述，这样用户就能看到了；</li>
<li>404：该状态码表明服务器上无法找到请求的资源，除此之外，也可以在服务器端拒绝请求且不想说明原因时使用；</li>
<li>405：发起的请求中带有请求 URL 所不支持的请求方法时返回该状态码，上一篇分享中我们已经提及；</li>
<li>406：客户端可以指定参数来说明它们愿意接收什么类型的实体，服务器没有与客户端可接受的 URL 相匹配的资源时，返回此状态码；</li>
<li>407：与 401 状态码类似，但用于要求对资源进行认证的代理服务器；</li>
<li>408：客户端请求超时，服务器返回此状态码并关闭连接；</li>
<li>409：说明请求可能在资源上引发冲突时返回此状态码；</li>
<li>410：与 404 类似，只是服务器曾经拥有过此资源，现在被移除了；</li>
<li>411：服务器要求请求报文中包含 Content-Length 首部时使用；</li>
<li>412：客户端发起条件请求，但其中一个条件失败时使用；</li>
<li>413：客户端发送的实体主体部分超过服务器处理的上限，一般上传大文件时会出现这种情况；</li>
<li>414：客户端发送请求中的请求 URL 超过服务器能处理的长度上限，返回此状态码；</li>
<li>415：服务器无法理解或无法支持客户端所发送实体的内容类型。</li>
</ul>
</li>
<li>**5XX：**服务器错误状态码
<ul>
<li>500：该状态码表明服务器端在执行请求时发生了错误，也可能是 Web 应用程序存在的 bug 或某些临时的故障；</li>
<li>501：客户端发起的请求超出服务器能力的范围；</li>
<li>502：作为代理或网关使用的服务器从请求响应链的下一条链路上收到了一条伪响应时返回此状态码；</li>
<li>503：该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求，如果事先得知解除以上状况需要的时间，最好写入 Retry-After 首部字段再返回给客户端；</li>
<li>504：与状态码 408 相似，这是这里的响应来自网关或代理，它们在等待另一个服务器对其请求进行响应的时候超时了，比如 php-fpm 故障或没有启动，通过 nginx 访问应用的时候会返回此状态码；</li>
<li>505：服务器收到的请求使用了它无法支持的协议版本时，使用此状态码。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>**原因短语（reason-phrase）：**数字状态码的可读版本；</p>
</li>
<li>
<p>**首部字段（headers）：**可以有零个或多个首部，每个首部都包含一个名字，后面跟着一个冒号，然后是一个可选的空格，接着是一个值，最后是一个 CR+LF（即<code>\r\n</code>），报文首部是由一个空行结束的，表示了首部列表的结束和实体主体部分的开始；</p>
<ul>
<li>
<p>通用首部字段：请求报文和响应报文都可以使用的首部字段；</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cache-Control</td>
<td>控制缓存的行为</td>
</tr>
<tr>
<td>Connection</td>
<td>逐跳首部、连接的管理</td>
</tr>
<tr>
<td>Date</td>
<td>创建报文的日期时间</td>
</tr>
<tr>
<td>Pragma</td>
<td>报文指令</td>
</tr>
<tr>
<td>Trailer</td>
<td>报文末端的首部一览</td>
</tr>
<tr>
<td>Transfer-Encoding</td>
<td>指定报文主体的传输编码方式</td>
</tr>
<tr>
<td>Upgrade</td>
<td>升级为其他协议</td>
</tr>
<tr>
<td>Via</td>
<td>代理服务器的相关信息</td>
</tr>
<tr>
<td>Warning</td>
<td>错误通知</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>请求首部字段：从客户端向服务器发送请求报文时使用的首部字段；</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept</td>
<td>用户代理可处理的媒体类型</td>
</tr>
<tr>
<td>Accept-Charset</td>
<td>优先的字符集</td>
</tr>
<tr>
<td>Accept-Encoding</td>
<td>优先的内容编码</td>
</tr>
<tr>
<td>Accept-Language</td>
<td>优先的语言（自然语言）</td>
</tr>
<tr>
<td>Authorization</td>
<td>Web认证信息</td>
</tr>
<tr>
<td>Except</td>
<td>期待服务器的特定行为</td>
</tr>
<tr>
<td>From</td>
<td>用户的电子邮箱地址</td>
</tr>
<tr>
<td>Host</td>
<td>请求资源所在服务器</td>
</tr>
<tr>
<td>If-Match</td>
<td>比较实体标记（ETag）</td>
</tr>
<tr>
<td>If-Modified-Since</td>
<td>比较资源的更新时间</td>
</tr>
<tr>
<td>If-None-Match</td>
<td>比较实体标记（与If-Match相反）</td>
</tr>
<tr>
<td>If-Range</td>
<td>资源未更新时发送实体Byte的范围请求</td>
</tr>
<tr>
<td>If-Unmodified-Since</td>
<td>比较资源的更新时间（与If-Modified-Since相反）</td>
</tr>
<tr>
<td>Max-Forwards</td>
<td>最大传输逐跳数</td>
</tr>
<tr>
<td>Proxy-Autherization</td>
<td>代理服务器要求客户端的认证信息</td>
</tr>
<tr>
<td>Range</td>
<td>实体的字节范围请求</td>
</tr>
<tr>
<td>Referer</td>
<td>对请求中URI的原始获取方式</td>
</tr>
<tr>
<td>TE</td>
<td>传输编码的优先级</td>
</tr>
<tr>
<td>User-Agen</td>
<td>HTTP客户端程序的信息</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>响应首部字段：从服务器端向向客户端返回响应报文时使用的首部字段；</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Accept-Ranges</td>
<td>是否接受字节范围请求</td>
</tr>
<tr>
<td>Age</td>
<td>推算资源创建时间</td>
</tr>
<tr>
<td>ETag</td>
<td>资源的匹配信息</td>
</tr>
<tr>
<td>Location</td>
<td>令客户端重定向至指定URI</td>
</tr>
<tr>
<td>Proxy-Authenticate</td>
<td>代理服务器对客户端的认证信息</td>
</tr>
<tr>
<td>Retry-After</td>
<td>对再次发送请求的时机要求</td>
</tr>
<tr>
<td>Server</td>
<td>HTTP服务器的安装信息</td>
</tr>
<tr>
<td>Vary</td>
<td>代理服务器缓存的还礼信息</td>
</tr>
<tr>
<td>WWW-Authenticate</td>
<td>服务器对客户端的认证信息</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>实体首部字段：针对请求报文和响应报文的实体部分使用的首部字段；</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Allow</td>
<td>资源可支持的HTTP方法</td>
</tr>
<tr>
<td>Content-Encoding</td>
<td>实体主体适用的编码方式</td>
</tr>
<tr>
<td>Content-Language</td>
<td>实体主体的自然语言</td>
</tr>
<tr>
<td>Content-Length</td>
<td>实体主体的大小（单位：字节）</td>
</tr>
<tr>
<td>Content-Location</td>
<td>替代对应资源的URI</td>
</tr>
<tr>
<td>Content-MD5</td>
<td>实体主体的报文摘要</td>
</tr>
<tr>
<td>Content-Range</td>
<td>实体主体的位置范围</td>
</tr>
<tr>
<td>Content-Type</td>
<td>实体主体的媒体类型</td>
</tr>
<tr>
<td>Expires</td>
<td>实体主体过期的日期时间</td>
</tr>
<tr>
<td>Last-Modified</td>
<td>资源的最后修改日期</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>扩展首部字段：非 HTTP 协议标准规定的首部字段，通常由开发者创建，用于某些特殊用途，比如 Cookie、Set-Cookie。</p>
<ul>
<li>Set-Cookie：开始状态管理所使用的Cookie信息（响应首部字段）
<ul>
<li><code>expires</code>：指定 Cookie 的有效期，省略的话默认在浏览器会话时间内有效（浏览器关闭失效），Cookie 一旦发送至客户端，就不能在服务器端显式删除，只能通过覆盖实现对客户端 Cookie 的「删除」；</li>
<li><code>Max-Age</code>：和 <code>expires</code> 作用类似，用于指定从现在开始该 Cookie 存在的秒数，如果同时指定了 <code>expires</code> 和 <code>Max-Age</code>，那么 <code>Max-Age</code> 的值将优先生效；</li>
<li><code>path</code>：指定 Cookie 生效的路径，默认路径是根路径 <code>/</code>；</li>
<li><code>domain</code>：指定 Cookie 所属的域名，省略的话默认是当前域名，Cookie 只有在所属域名下才能获取，不能跨域名获取 Cookie，比如在 <code>laravelacademy.org</code> 对应应用下生成的 Cookie 所属域名是 <code>laravelacademy.org</code>，对应 Cookie 只能在 <code>laravelacademy.org</code> 域名应用下获取，在 <code>blog.laravelacademy.org</code> 对应应用下生成的 Cookie 所属域名是 <code>blog.laravelacademy.org</code>，对应 Cookie 只能在 <code>blog.laravelacademy.org</code> 域名应用下获取，依次类推。我们还可以通过通配符在生成 Cookie 时指定所属域名为 <code>*.laravelacademy.org</code>，这样一来，不管是 <code>laravelacademy.org</code> 还是 <code>blog.laravelacademy.org</code>，都可以获取到相应的 Cookie；</li>
<li><code>secure</code>：限制浏览器只有在页面启用 HTTPS 安全连接时才可以发送 Cookie，省略的话，无论 HTTP 还是 HTTPS 都可以发送；</li>
<li><code>httponly</code>：是 Cookie 的扩展功能，使 JavaScript 无法获取 Cookie，主要目的是为了防止跨站脚本攻击（XSS）对 Cookie 信息的窃取。</li>
</ul>
</li>
<li>Cookie：服务器接收到的Cookie信息（请求首部字段）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>**主体（entity-body）：**包含一个由任意数据组成的数据块，并不是所有报文都包含实体的主体部分</p>
</li>
</ul>
<h3 id="web服务器">WEB服务器</h3>
<p><strong>工作流程</strong></p>
<ul>
<li>建立连接：由于 HTTP 通信是基于 TCP 协议的，所以需要先建立连接才能开始通信，这也是为什么我们在实现 Web 服务器的时候要指定 IP 和端口的原因，客户端可以根据这个 IP 地址和端口号与服务器建立连接（TCP 的三次握手）；</li>
<li>接收请求：一旦服务器与客户端建立连接后，服务器就可以接收从客户端发过来的请求报文，第一次请求时先建立连接，对于 HTTP/1.1 来说，默认支持持续连接，所以后续请求都可以在这个连接上进行，不需要额外建立连接；</li>
<li>处理请求：服务器收到请求报文并解析完成后（主要是请求首部），会对请求进行处理，比如 POST 请求需要包含请求实体，判断是否有访问权限，指定路径是否存在，返回缓存还是原始资源，如果是静态资源的话（比如 HTML、图片、CSS 文件等）直接从文件系统获取并返回即可，如果是动态资源的话，还需要通过 CGI 网关请求后端应用程序接口（PHP、Java、Python 等编写的应用程序），如果配置了负载均衡，还要将请求进行转发；</li>
<li>访问资源：服务器根据请求处理结果去指定位置获取资源，如果资源存储在缓存中从缓存获取，存储在文件系统中从文件系统获取，存储在 CDN 中从 CDN 处获取，存储在数据库中则从数据库获取等；</li>
<li>构建响应：请求处理完成并获取到对应的资源后，服务器开始构建响应报文，响应首部和响应实体的设置需要遵循 HTTP 协议规范；</li>
<li>返回响应：响应报文构建完成后，会沿着请求来路将其返回给客户端，如果当前 HTTP 连接是持久连接的话，需要保持连接打开状态，否则会关闭连接，此时，需要注意的是对持久连接而言，响应头中必须包含 Content-Length 首部字段，否则客户端不知道什么时候响应实体结束；</li>
<li>记录日志：当一个 HTTP 事务（请求响应）结束后，Web 服务器通常会在日志中记录该事务。</li>
</ul>
<h3 id="php-fpm">PHP-FPM</h3>
<p>PHP-FPM 的全称是 PHP FastCGI Process Manager，即 PHP FastCGI 进程管理器，要了解 PHP-FPM ，首先要看看 CGI 与 FastCGI 的关系。</p>
<p>CGI 的英文全名是 Common Gateway Interface，即通用网关接口，是 Web 服务器调用外部程序时所使用的一种服务端应用的规范。引入 CGI 以便客户端请求能够触发 Web 服务器运行另一个外部程序，客户端所输入的数据也会传给这个外部程序，该程序运行结束后会将生成的 HTML 和其他数据通过 Web 服务器再返回给客户端（即动态请求，比如基于 PHP、Python、Java 实现的应用）。利用 CGI 可以针对用户请求动态返回给客户端各种各样动态变化的信息。CGI 可以针对用户请求动态返回给客户端各种各样动态变化的信息。</p>
<p>FastCGI 顾名思义，是 CGI 的升级版本，为了提升 CGI 的性能而生，CGI 针对每个 HTTP 请求都会 <code>fork</code> 一个新进程来进行处理（解析配置文件、初始化执行环境、处理请求），然后把这个进程处理完的结果通过 Web 服务器转发给用户，刚刚 <code>fork</code> 的新进程也随之退出，如果下次用户再请求动态资源，那么 Web 服务器又再次 <code>fork</code> 一个新进程，如此周而复始循环往复。而 FastCGI 则会先 <code>fork</code> 一个 <code>master</code> 进程，解析配置文件，初始化执行环境，然后再 <code>fork</code> 多个 <code>worker</code> 进程（与 Nginx 有点像），当 HTTP 请求过来时，<code>master</code> 进程将其会传递给一个 <code>worker</code> 进程，然后立即可以接受下一个请求，这样就避免了重复的初始化操作，效率自然也就提高了。而且当 <code>worker</code> 进程不够用时，<code>master</code> 进程还可以根据配置预先启动几个 <code>worker</code> 进程等着；当空闲 <code>worker</code> 进程太多时，也会关掉一些，这样不仅提高了性能，还节约了系统资源。</p>
<p>FastCGI 只是一个协议规范，需要每个语言具体去实现，PHP-FPM 就是 PHP 版本的 FastCGI 协议实现，有了它，就是实现 PHP 脚本与 Web 服务器（通常是 Nginx）之间的通信，同时它也是一个 PHP SAPI，从而构建起 PHP 解释器与 Web 服务器之间的桥梁。</p>
<p>PHP-FPM 负责管理一个进程池来处理来自 Web 服务器的 HTTP 动态请求，在 PHP-FPM 中，<code>master</code> 进程负责与 Web 服务器进行通信，接收 HTTP 请求，再将请求转发给 <code>worker</code> 进程进行处理，<code>worker</code> 进程主要负责动态执行 PHP 代码，处理完成后，将处理结果返回给 Web 服务器，再由 Web 服务器将结果发送给客户端。这就是 PHP-FPM 的基本工作原理，</p>
<p>PHP-FPM 有自己独立的配置文件 <code>php-fpm.conf</code> 用于对 PHP-FPM 进行配置。</p>
<h3 id="lnmp">LNMP</h3>
<p><strong>工作流程</strong></p>
<ul>
<li>
<p><strong>建立连接：</strong></p>
<ul>
<li>
<p>Nginx 服务启动后就会启动一个 <code>master</code> 进程和多个 <code>worker</code> 进程（一般与 CPU 个数相同），<code>master</code> 主要负责处理 Nginx 主服务的启动、关闭与重载，以及维护 <code>worker</code> 进程的运行状态，具体的 HTTP 连接与请求处理工作由 <code>worker</code> 进程来完成，每个 <code>worker</code> 进程上都可以处理多个连接请求，底层实现的原理是事件驱动和多路 IO 复用，这一点和 Apache <code>fork</code> 多个子进程来处理请求不同，从而实现了 Nginx 的高并发</p>
</li>
<li>
<p>客户端输入应用 URL 进行访问时，可以通过三次握手建立与对端 Web 服务器应用的 TCP 连接了，这个对端 Web 服务器应用正是 Nginx，Nginx 的 <code>master</code> 进程在接收客户端连接信号后会将这个网络事件发送给某个 <code>worker</code> 进程，由该 <code>worker</code> 进程来接管后续的连接建立和请求处理，经过这一步，就建立起了 Nginx 服务器与本地客户端的连接</p>
</li>
<li>
<p>端建立 HTTP 连接之后，就开始从这条连接上读取请求报文数据（对应 Socket 编程中的 <code>read</code> 操作）并进行解析，Nginx 会遵循 HTTP 协议对起始行、报文首部及报文主体进行进行解析，并获取请求方法、请求 URL、请求参数、HTTP 协议版本等信息，然后将解析出来的请求数据保存到 Nginx 对应的数据结构 <code>ngx_http_request_s</code> 中</p>
<blockquote>
<p>在解析过程中，如果发现请求方法或请求首部字段不合法，则直接返回错误响应，比如不支持对应的请求方法，返回 <code>405 Method Not Allowed</code> 响应，对于 HTTP/1.1 而言，如果请求首部不包含 <code>Host</code> 字段，则返回 <code>400 Bad Request</code> 响应，请求超时也是在这一阶段检查的</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>处理请求：</strong></p>
<ul>
<li>
<p>Nginx 是由模块驱动的，所以会通过配置文件中定义的 http 主模块及里面包含的 server 子模块以及更细粒度的 location 子模块依次对 HTTP 请求进行处理</p>
<ul>
<li>
<p>**静态资源：**比如 <code>http://laravel58.test/favicon.ico</code>，则 Nginx 会通过 <code>location / {...}</code> 中的配置直接从 <code>/var/www/laravel/public/favicon.ico</code> 获取对应资源，如果对应资源存在，则返回 <code>200 OK</code> 响应，否则返回 <code>404</code> 响应</p>
</li>
<li>
<p>**非静态资源：**比如 <code>http://laravel58.test</code>，通过 <code>location / {...}</code> 配置，Nginx 首先将请求 URL 转化为 <code>http://laravel58.test/</code> 并再次发起请求（对用户而言是透明无感知的），这一次，<code>index</code> 配置生效，Nginx 会尝试通过 <code>/var/www/laravel/public/index.php</code> 匹配资源是否存在，资源存在则将访问该资源，由于该资源以 <code>.php</code> 结尾，所以 <code>location ~ \.php$ {...}</code> 配置生效，Nginx 会继续通过该配置对进行处理</p>
<blockquote>
<p>这里面的配置其实是个反向代理配置，Nginx 本身的高性能高并发设计更适用于作为静态资源服务器，对应 PHP 脚本文件这种动态资源请求，Nginx 的处理方式是通过反向代理的方式将其转发给真正的 PHP 脚本处理进程，通常是 PHP-FPM</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>访问资源：</strong></p>
<ul>
<li>
<p>Nginx 作为反向代理服务器会将请求转发给相应的 CGI 后台进程，在 PHP 中，一般是 PHP-FPM（PHP FastCGI 进程管理器），然后再由 PHP-FPM 将请求转交给对应的 PHP 脚本，并由 PHP 解释器来执行相应的代码，在 Laravel 框架中，对应的处理流程就是从入口文件 <code>public/index.php</code> 开始，经过应用初始化-&gt;中间件过滤-&gt;路由匹配-&gt;请求验证-&gt;业务逻辑执行-&gt;返回响应这一系列步骤最终将处理结果即最终获取到的动态资源返回给 Nginx</p>
<blockquote>
<p>为了加速用户对静态资源访问的速度，现在很多中大型网站会普遍使用 CDN 技术让终端用户就近从附近运营商数据中心获取缓存的静态资源</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>构建&amp;发送响应：</strong></p>
<ul>
<li>
<p>Nginx 通过 <code>ngx_http_send_header</code> 方法构造 HTTP 响应的起始行、响应首部，并将响应头信息保存在 <code>ngx_http_request_s</code> 的 <code>headers_out</code> 数据结构中，然后通过 <code>ngx_http_header_filter</code> 方法按照 HTTP 规范将其序列化为字节流缓冲区，最后通过 <code>ngx_http_write_filter</code> 方法将响应头部发送出去</p>
<blockquote>
<p>PHP 代码中通过 <code>header</code>、<code>set_cookie</code> 等网络函数设置的响应头也会通过 PHP-FPM 发送给 Nginx</p>
</blockquote>
</li>
<li>
<p>HTTP 响应实体保存在 <code>ngx_http_request_s</code> 的 <code>out</code> 链表中（对于响应头部过大无法一次性发送完的响应，也会将剩余的响应头部放到 out 链表），经由 <code>ngx_http_out_filter</code> 过滤处理之后，最后也是通过 <code>ngx_http_write_filter</code> 方法将响应实体发送出去</p>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">server {
    listen 80;    // IPv4
    listen [::]:80;  // IPv6

    server_name laravel.test;
    root /var/www/laravel/public;
    index index.php index.html index.htm;

    location / {
         try_files $uri $uri/ /index.php$is_args$args;
    }

    location ~ \.php$ {
        try_files $uri /index.php =404;
        fastcgi_pass unix:/run/php/php7.1-fpm.sock;
        fastcgi_index index.php;
        fastcgi_buffers 16 16k;
        fastcgi_buffer_size 32k;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        #fixes timeouts
        fastcgi_read_timeout 600;
        include fastcgi_params;
    }

    location ~ /\.ht {
        deny all;
    }

    error_log /var/log/nginx/laravel_error.log;
    access_log /var/log/nginx/laravel_access.log;
}
</code></pre></td></tr></table>
</div>
</div><h3 id="http缓存">HTTP缓存</h3>
<p>这里讨论的缓存是基于 HTTP 协议实现的缓存，这些缓存通常存储在 HTTP 客户端，通过请求头或响应头来协商和标识，而不是那些存储在 Memcached 或者 Redis 服务器中的缓存，后者更多用来缓存从数据库中获取的数据。</p>
<p>在客户端首次获取到这些静态文件后，将这些变动频率很低的静态文件缓存到客户端，这样，客户端下次发起请求时，就可以直接从本地获取对应的缓存文件，不必每次都从服务器获取，就可以提高服务器的负载，进而提升服务器的性能，同时还会减少网络流量，降低客户端请求等待延迟，从而提升客户端用户的体验。</p>
<ul>
<li>
<p><strong>种类：</strong></p>
<ul>
<li>私有缓存：作用于单个用户，通常就是浏览器缓存</li>
<li>共享缓存：往往存放在可以被多个用户共享的代理之中，所以有时候也叫代理缓存</li>
<li>网关缓存</li>
<li>反向代理缓存</li>
<li>CDN缓存</li>
</ul>
</li>
<li>
<p><strong>原理：</strong></p>
<ul>
<li>
<p>接收：读取请求报文；</p>
</li>
<li>
<p>解析：对请求报文进行解析，提取 URL 和各种首部字段；</p>
</li>
<li>
<p>查询：查看是否有本地缓存可用（新鲜度检查），若没有，则从服务器获取相应的资源并存储到本地；</p>
<blockquote>
<p>新鲜度检查：缓存不会一直有效，所谓的「新鲜度」指的是和食品的保质期类似，缓存是有有效期的，在有效期之内才可以使用，否则需要向服务器查询对应资源是否有更新；</p>
</blockquote>
</li>
<li>
<p>创建响应：缓存会用新的首部和缓存的响应主体来构建响应报文；</p>
</li>
<li>
<p>发送：将响应发送给客户端；</p>
</li>
<li>
<p>日志：缓存可以创建一条日志来记录这个 HTTP 事务。</p>
</li>
</ul>
</li>
<li>
<p><strong>实现机制：</strong> 基于 HTTP 协议的 HTTP 缓存是通过在请求头和响应头中设置相应的字段值来实现的</p>
<ul>
<li>Expires：
<ul>
<li>字段的值为服务端返回的缓存资源到期时间（绝对时间），即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据</li>
<li>是 HTTP/1.0 的东西，所以它的作用基本忽略</li>
<li>到期时间是服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差</li>
</ul>
</li>
<li>Cache-Control：<code>no-store</code>、<code>no-cache</code>、<code>public</code>、<code>private</code>、<code>max-age</code>、<code>must-revalidate</code></li>
<li>Last-Modified/If-Modified-Since：前者在响应头中、后者在请求头中，服务器进行比较</li>
<li>Etag/If-None-Match：前者在响应头中，是资源在服务器的唯一标识（每当资源发生修改后 <code>Etag</code> 值会变化）</li>
</ul>
</li>
</ul>
<p><!-- raw HTML omitted --></p>
<h4 id="laravel">LARAVEL</h4>
<p>在实际项目中，基于客户端浏览器的私有缓存并不是主流的实现方案，因为服务端页面更新后，往往需要用户主动刷新页面才能清空缓存，并不便于服务端去控制，所以针对 HTTP 缓存，使用网关缓存的实现更为主流，比如我们比较熟悉的 CDN 缓存、反向代理缓存都属于这一范畴</p>
<ul>
<li><strong>浏览器缓存：</strong>
<ul>
<li>强制缓存：
<ul>
<li><code>return response()-&gt;setExpires(new DateTime(date(DATE_RFC7231, time() + 3600)));</code></li>
<li><code>return response()-&gt;setClientTtl(3600);</code></li>
</ul>
</li>
<li>对比缓存：对比验证缓存是否过期来实现 HTTP 缓存
<ul>
<li><code>return response-&gt;setContent('Cache-Control: no-cache,max-age=3600,private')</code></li>
<li><code>return response-&gt;setLastModified('固定值')</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>网关缓存：</strong> 这里要介绍的网关缓存主要就是反向代理缓存，常见的反向代理服务器有 Nginx、Varnish、Squid 等，但是这里为了简化模型，将使用 Symfony 框架提供的 HTTP Cache 功能来做演示
<ul>
<li>安装：
<ul>
<li><code>composer require barryvdh/laravel-httpcache</code></li>
<li>在 <code>app/Http/Kernel.php</code> 的 <code>web</code> 中间件组中添加一个中间件： <code>\Barryvdh\HttpCache\Middleware\CacheRequests::class,</code></li>
</ul>
</li>
<li>使用代码和原先基本一致</li>
</ul>
</li>
</ul>
<h3 id="cdn缓存">CDN缓存</h3>
<p>CDN 的英文全称是 Content Delivery Network，即内容分发网络。CDN 缓存其实是应用服务提供商与网络服务提供商签约，将应用指定的静态资源保存到网络服务提供商的边缘节点，因为用户接入互联网都是通过网络服务商实现的，不同用户使用的网络服务商（如电信、联通、移动）不尽相同，用户通过自己所在网络服务商的边缘节点、区域节点、中心节点最终接入应用所在的数据中心，才能访问到应用服务端资源，其中边缘节点是离用户最近的运营商服务器节点，应用服务商与网络服务商签约后，就可以将静态资源缓存到这些边缘节点，这样，不同区域的用户就可以就近从边缘节点获取缓存资源，从而极大提高访问速度，所以 CDN 主要解决的是下面两个问题：</p>
<ul>
<li>CDN 缓存解决了跨运营商和跨地域访问的问题，访问延时大大降低；</li>
<li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，降低了应用所在服务器的负载。</li>
</ul>
<p><strong>实现原理</strong></p>
<ol>
<li>在 <code>web.com</code> 对应的权威 DNS 服务器上，会设置一个 <code>CNAME</code> 别名（这可以通过在域名服务商那里通过设置 <code>CNAME</code> 域名解析实现），指向另外一个域名，假设这个域名是 <code>www.web.cdn.com</code>，并将其返回给本地 DNS 服务器</li>
<li>当本地 DNS 服务器拿到这个新的域名时，需要继续解析这个新的域名<code>www.web.cdn.com</code>，在这个服务器上，还是会设置一个 <code>CNAME</code>，指向另外一个域名，也即 CDN 网络的全局负载均衡器</li>
<li>本地 DNS 服务器去请求 CDN 的全局负载均衡器解析域名，全局负载均衡器会为用户选择一台合适的缓存服务器提供服务，选择的依据包括：
<ul>
<li>根据用户 IP 地址，判断哪一台服务器距用户最近；</li>
<li>用户所处的网络运营商；</li>
<li>根据用户所请求的 URL 中携带的内容名称，判断哪一台服务器上有用户所需的内容；</li>
<li>查询各个服务器当前的负载情况，判断哪一台服务器尚有服务能力。</li>
</ul>
</li>
<li>基于以上这些条件，进行综合分析之后，全局负载均衡器会返回一台缓存服务器的 IP 地址</li>
<li>本地 DNS 服务器缓存这个 IP 地址，然后将其返回给客户端，客户端再根据这个 IP 地址去访问对应的边缘节点，下载资源</li>
<li>如果该边缘节点上并没有用户想要的内容，那么这台服务器就要向它的上一级节点请求内容，直至追溯到网站的源服务器将内容拉取到本地</li>
</ol>
<p><img src="/img/network-protocol_19.jpg" alt=""></p>
<h3 id="https">HTTPS</h3>
<p>HTTP 协议设计的初衷就是简单方便，但是随着 Web 的发展和交互的复杂，也引入了一些安全性问题：</p>
<ul>
<li>通信使用明文，内容可能会被窃听：HTTP 协议本身不具备加密功能，所以无法对通信整体（请求和响应的内容）进行加密，即 HTTP 报文使用明文方式发送。按照 TCP/IP 协议族的工作机制，通信内容在所有线路上都有可能被窃听。</li>
<li>不验证通信方的身份，因此有可能遭遇伪装：HTTP 协议中的请求和响应不会对通信方进行确认，所以任何人都可以发起请求，另外，服务器只要接收到请求，不管对方是谁都会返回一个响应，即使是伪装的客户端。另外，即使是无意义的请求也会处理，无法阻止海量请求下的 DoS 攻击。</li>
<li>无法证明报文的完整性，所以有可能已遭篡改：没有任何办法确认发出的请求/响应和接收到的请求/响应是前后相同的，请求或响应在传输途中，遭攻击者拦截并篡改内容的攻击称为中间人攻击（Main-in-the-Middle attack，MITM）。</li>
</ul>
<p>HTTPS 的英文全名是 HTTP Secure 或 HTTP over SSL，即基于 SSL 的安全 HTTP 协议。SSL 会建立一个安全的通信线路，在此线路上传输的内容都会经过加密处理，此外 SSL 还通过证书的方式来确认通信双方的身份，这样就可以从源头上杜绝了通信方被伪装以及信息被窃听和篡改的可能性，从而确保 HTTP 通信的安全。</p>
<p>TLS（Transport Layer Security，传输层安全）是 SSL 的升级版（Secure Socket Layer，安全套接层），建立在 SSL 3.0 协议规范之上，由于 SSL 这一术语非常常用，所以通常我们把 SSL 和 TLS 统称为 SSL，从这个角度来说，不管是基于 TLS 还是 SSL 实现的 HTTPS，将其描述为 HTTP over SSL 并没有什么问题。</p>
<h4 id="相关术语"><strong>相关术语</strong></h4>
<ul>
<li>
<p><strong>对称加密：</strong></p>
<ul>
<li>在对称加密算法中，加密和解密使用的密钥是相同的。在互联网上转发密钥，如果通信被监听那么密钥就会落入攻击者之手，存在安全隐患，另外还得设法安全地保管接收到的密钥。</li>
</ul>
</li>
<li>
<p><strong>非对称加密：</strong></p>
<ul>
<li>在非对称加密算法中，加密使用的密钥和解密使用的密钥是不相同的。一把是作为公开的公钥，另一把是作为谁都不能给的私钥。公钥加密的信息，只有私钥才能解密；私钥加密的信息，只有公钥才能解密。</li>
<li>使用这种加密方式，发送密文的一方使用公钥进行加密，对方收到加密信息后，使用私钥进行解密。利用这种方式，不需要发送用来解密的私钥，也不必担心密钥被攻击者窃听而盗走，故而安全性更高，但与对称加密相比，算法和实现更加复杂，处理速度更慢</li>
<li>HTTPS 充分两种加密方式的优势，在交换密钥环节使用非对称加密，之后的建立通信交换报文阶段则使用对称加密</li>
</ul>
</li>
<li>
<p><strong>数字证书：</strong></p>
<ul>
<li>
<p>通过 OpenSSL 提供的命令就可以生成私钥和公钥，但是需要权威机构颁发证书（Certificate）才能被承认，否则我们无法判断通信中传递的公钥是否是目标服务器返回的</p>
</li>
<li>
<p>认证过程：</p>
<ul>
<li>
<p>生成证书需要发起一个证书请求，然后将这个请求发给一个权威机构（客户端和服务端都信任的第三方结构）去认证，这个权威机构我们称之为 CA（Certificate Authority）。权威机构会给证书敲一个章，也就是所谓的签名算法。</p>
<blockquote>
<p>签名算法大概是这样工作的：一般是对信息做一个 Hash 计算，得到一个 Hash 值，这个过程是不可逆的，也就是说无法通过 Hash 值得出原来的信息内容。在把信息发送出去时，把这个 Hash 值通过 CA 的私钥加密后，作为一个签名和信息一起发出去</p>
</blockquote>
</li>
<li>
<p>CA 用自己的私钥给网站的公钥签名，就相当于给网站背书，形成了网站的证书</p>
</li>
<li>
<p>CA 的公钥需要更牛的 CA 给它签名，形成 CA 的证书，要想看 CA 的证书是否可靠，要看 CA 的上级证书的公钥，能不能解开这个 CA 的签名。这样层层上去，直到全球皆知的几个著名大 CA，称为 root CA，做最后的背书。通过这种层层授信背书的方式，从而保证了非对称加密模式的正常运转</p>
</li>
<li>
<p>服务器会将这份 CA 颁发的公钥证书（也可以叫做数字证书）发送给客户端，以进行非对称加密方式通信</p>
</li>
<li>
<p>接到证书的客户端可使用 CA 提供的公钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：</p>
<ol>
<li>认证服务器公钥的是真实有效的数字证书认证机构；</li>
<li>服务器的公钥是值得信赖的。</li>
</ol>
<blockquote>
<p>此处 CA 的公钥必须安全转交给客户端，如何安全转交是件很困难的事，因此，大多数浏览器开发商发布版本时，会事先在内部植入常见 CA 的公钥</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="底层实现">底层实现</h4>
<p><img src="/img/network-protocol_20.png" alt=""></p>
<ol>
<li>当我们访问一个 HTTPS 网站的时候，客户端通过发送 <code>Client Hello</code> 报文开始建立与服务器的 SSL 通信，报文中包含了 SSL 协议版本、加密组件、压缩算法等信息，另外，还有一个随机数，用于后续对称加密密钥的协商。</li>
<li>服务器可以进行 SSL 通信时，会以 <code>Server Hello</code> 报文作为应答，和客户端一样，在报文中包含 SSL 协议版本、加密组件、压缩算法等信息，同时还有一个随机数，用于后续对称加密密钥的协商。</li>
<li>接下来，服务器会以 <code>Certificate</code> 报文的形式给客户端发送服务端的数字证书，其中包含了非对称加密用到的公钥信息。最后，服务器还会发送 <code>Server Hello Done</code> 报文告知客户端，最初阶段的 SSL 握手协商部分结束。</li>
<li>客户端当然不相信这个证书，于是从自己信任的 CA 仓库中，拿 CA 证书里面的公钥去解密 HTTPS 网站的数字证书（证书是通过 CA 私钥加密的，所以要用公钥解密），如果能够成功，则说明 HTTPS 网站是可信的。</li>
<li>证书验证完毕之后，觉得这个 HTTPS 网站可信，于是客户端计算产生随机数字 <code>Pre-master</code>，用服务器返回的数字证书中的公钥加密该随机数字，再通过 <code>Client Key Exchange</code> 报文发送给服务器，服务器可以通过对应的私钥解密出 <code>Pre-master</code>。到目前为止，无论是客户端还是服务器，都有了三个随机数，分别是：自己的、对端的，以及刚生成的 <code>Pre-Master</code> 随机数。通过这三个随机数，可以在客户端和服务器生成相同的对称加密密钥。</li>
<li>有了对称加密密钥，客户端就可以通过 <code>Change Cipher Spec</code> 报文告知服务器以后都采用该密钥和协商的加密算法进行加密通信了。</li>
<li>然后客户端还会发送一个 <code>Encrypted Handshake Message</code> 报文，将已经商定好的参数，采用对称加密密钥进行加密，发送给服务器用于数据与握手验证。</li>
<li>同样，服务器也可以发送 <code>Change Cipher Spec</code> 报文，告知客户端以后都采用协商的对称加密密钥和加密算法进行加密通信了，并且也发送 <code>Encrypted Handshake Message</code> 报文进行测试。当双方握手结束之后，就可以通过对称加密密钥进行加密传输了。</li>
</ol>
<p>上面的过程只包含了 HTTPS 的单向认证，也即客户端验证服务端的证书，大部分场景下使用的都是单向认证，也可以在更加严格安全要求的情况下，启用双向认证，双方互相验证证书，比如银行的网银系统就是这样，需要客户端安装数字证书后才能登录，其实就要服务端要要验证客户端的合法性。</p>
<h3 id="http认证">HTTP认证</h3>
<p><strong>客户端表明自己身份的方式主要有以下几种：</strong></p>
<ul>
<li>密码</li>
<li>令牌（可以看作是动态生成的密码，多用于 API 认证）</li>
<li>数字证书</li>
<li>生物认证（比如指纹、刷脸）</li>
</ul>
<p><strong>服务端进行认证的方式主要有以下几种：</strong></p>
<ul>
<li>
<p>基本认证</p>
<ul>
<li>HTTP/1.0 中定义了基本认证的实现，HTTP/1.1 仍然支持，Laravel 框架中提供的 <a href="https://xueyuanjun.com/post/19948#toc-%E5%9F%BA%E4%BA%8E-http-%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81">HTTP 基本认证</a>功能就是基于此标准实现的</li>
<li>凭证信息是用户名和密码通过冒号拼接起来，然后通过 Base64 进行编码，可以通过 Base64 解码即可还原，所以基本等同于明文传输</li>
<li>接收到包含 <code>Authorization</code> 请求头的服务器，会对凭证信息的正确性进行验证，验证通过，则返回一条包含 Request URL 资源的响应，否则仍然返回 <code>401</code> 响应，要求用户继续进行认证</li>
</ul>
</li>
<li>
<p>摘要认证</p>
<blockquote>
<p>TTP/1.1 引入了摘要（<code>Digest</code>）认证，摘要认证和基本认证流程一样，只是不会通过明文传递密码，它提供了防止密码被窃听的保护机制，但是不能有效防止用户伪装，而 HTTPS 则能够兼顾这两方面的安全需求，因此，摘要认证并没有得到广泛应用，随着 HTTPS 的流行而逐渐销声匿迹</p>
</blockquote>
</li>
<li>
<p>SSL 客户端认证</p>
<ul>
<li>SSL 客户端认证是借助 HTTPS 的客户端证书完成认证的方式，就像 HTTPS 的服务端证书可以确保服务器的合法性一样，HTTPS 的客户端证书可以确保登录设备是经过认证的合法设备</li>
<li>多数情况下，SSL 客户端认证会结合表单认证形成<strong>双因素认证</strong>（<code>Two-Factor Authentication</code>）</li>
</ul>
</li>
<li>
<p>表单认证</p>
<ul>
<li>表单认证并不是在 HTTP 协议中定义的，客户端会通过表单向服务器上的 Web 应用程序发送登录凭证（<code>Credential</code>），服务端按登录凭证的验证结果对用户进行认证</li>
<li>基于 Cookie 的 Session 技术</li>
</ul>
</li>
</ul>
<h3 id="websocket"><strong>WebSocket</strong></h3>
<p>一旦建立起 WebSocket 连接，不论是服务器还是客户端，都可以直接向对方发送报文。</p>
<p>为了实现 WebSocket 的通信，在 HTTP 连接建立之后，还需要完成一次「握手」的步骤：</p>
<p><!-- raw HTML omitted --></p>
<ol>
<li>WebSocket 复用了 HTTP 的握手通道，要建立 WebSocket 通信，需要在连接发起方的 HTTP 请求报文中通过 <code>Upgrade</code> 字段告知服务器通信协议升级到 Websocket，然后通过 <code>Sec-WebSocket-*</code> 扩展字段提供 WebSocket 的协议、版本、键值等信息</li>
<li>对于上述握手请求，服务器会返回 <code>101 Switching Protocols</code> 响应表示协议升级成功fuwu</li>
</ol>
<h4 id="服务器">服务器</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-php" data-lang="php"><span class="o">&lt;?</span><span class="nx">php</span>
<span class="c1">// 初始化 WebSocket 服务器，在本地监听 8000 端口
</span><span class="c1"></span><span class="nv">$server</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Swoole\WebSocket\Server</span><span class="p">(</span><span class="s2">&#34;localhost&#34;</span><span class="p">,</span> <span class="mi">8000</span><span class="p">);</span>

<span class="c1">// 建立连接时触发
</span><span class="c1"></span><span class="nv">$server</span><span class="o">-&gt;</span><span class="na">on</span><span class="p">(</span><span class="s1">&#39;open&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">Swoole\WebSocket\Server</span> <span class="nv">$server</span><span class="p">,</span> <span class="nv">$request</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s2">&#34;server: handshake success with fd</span><span class="si">{</span><span class="nv">$request</span><span class="o">-&gt;</span><span class="na">fd</span><span class="si">}</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// 收到消息时触发推送
</span><span class="c1"></span><span class="nv">$server</span><span class="o">-&gt;</span><span class="na">on</span><span class="p">(</span><span class="s1">&#39;message&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nx">Swoole\WebSocket\Server</span> <span class="nv">$server</span><span class="p">,</span> <span class="nv">$frame</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s2">&#34;receive from </span><span class="si">{</span><span class="nv">$frame</span><span class="o">-&gt;</span><span class="na">fd</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="nv">$frame</span><span class="o">-&gt;</span><span class="na">data</span><span class="si">}</span><span class="s2">,opcode:</span><span class="si">{</span><span class="nv">$frame</span><span class="o">-&gt;</span><span class="na">opcode</span><span class="si">}</span><span class="s2">,fin:</span><span class="si">{</span><span class="nv">$frame</span><span class="o">-&gt;</span><span class="na">finish</span><span class="si">}</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">;</span>
    <span class="nv">$server</span><span class="o">-&gt;</span><span class="na">push</span><span class="p">(</span><span class="nv">$frame</span><span class="o">-&gt;</span><span class="na">fd</span><span class="p">,</span> <span class="s2">&#34;this is server&#34;</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// 关闭 WebSocket 连接时触发
</span><span class="c1"></span><span class="nv">$server</span><span class="o">-&gt;</span><span class="na">on</span><span class="p">(</span><span class="s1">&#39;close&#39;</span><span class="p">,</span> <span class="k">function</span> <span class="p">(</span><span class="nv">$ser</span><span class="p">,</span> <span class="nv">$fd</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">echo</span> <span class="s2">&#34;client </span><span class="si">{</span><span class="nv">$fd</span><span class="si">}</span><span class="s2"> closed</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">;</span>
<span class="p">});</span>

<span class="c1">// 启动 WebSocket 服务器
</span><span class="c1"></span><span class="nv">$server</span><span class="o">-&gt;</span><span class="na">start</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="客户端">客户端</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-html" data-lang="html"><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">head</span><span class="p">&gt;</span>
   <span class="p">&lt;</span><span class="nt">meta</span> <span class="na">charset</span><span class="o">=</span><span class="s">&#34;UTF-8&#34;</span><span class="p">&gt;</span>
   <span class="p">&lt;</span><span class="nt">title</span><span class="p">&gt;</span>Chat Client<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">head</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">script</span><span class="p">&gt;</span>
   <span class="nb">window</span><span class="p">.</span><span class="nx">onload</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
       <span class="kd">var</span> <span class="nx">nick</span> <span class="o">=</span> <span class="nx">prompt</span><span class="p">(</span><span class="s2">&#34;Enter your nickname&#34;</span><span class="p">);</span>
       <span class="kd">var</span> <span class="nx">input</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s2">&#34;input&#34;</span><span class="p">);</span>
       <span class="nx">input</span><span class="p">.</span><span class="nx">focus</span><span class="p">();</span>

       <span class="c1">// 初始化客户端套接字并建立连接
</span><span class="c1"></span>       <span class="kd">var</span> <span class="nx">socket</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">WebSocket</span><span class="p">(</span><span class="s2">&#34;ws://localhost:8000&#34;</span><span class="p">);</span>
       
       <span class="c1">// 连接建立时触发
</span><span class="c1"></span>       <span class="nx">socket</span><span class="p">.</span><span class="nx">onopen</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
           <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Connection open ...&#34;</span><span class="p">);</span> 
       <span class="p">}</span>

       <span class="c1">// 接收到服务端推送时执行
</span><span class="c1"></span>       <span class="nx">socket</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
           <span class="kd">var</span> <span class="nx">msg</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">data</span><span class="p">;</span>
           <span class="kd">var</span> <span class="nx">node</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
           <span class="kd">var</span> <span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&#34;div&#34;</span><span class="p">);</span>
           <span class="nx">div</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">node</span><span class="p">);</span>
           <span class="nb">document</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">insertBefore</span><span class="p">(</span><span class="nx">div</span><span class="p">,</span> <span class="nx">input</span><span class="p">);</span>
           <span class="nx">input</span><span class="p">.</span><span class="nx">scrollIntoView</span><span class="p">();</span>
       <span class="p">};</span>
       
       <span class="c1">// 连接关闭时触发
</span><span class="c1"></span>       <span class="nx">socket</span><span class="p">.</span><span class="nx">onclose</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
           <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">&#34;Connection closed ...&#34;</span><span class="p">);</span> 
       <span class="p">}</span>

       <span class="nx">input</span><span class="p">.</span><span class="nx">onchange</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
           <span class="kd">var</span> <span class="nx">msg</span> <span class="o">=</span> <span class="nx">nick</span> <span class="o">+</span> <span class="s2">&#34;: &#34;</span> <span class="o">+</span> <span class="nx">input</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
           <span class="c1">// 将输入框变更信息通过 send 方法发送到服务器
</span><span class="c1"></span>           <span class="nx">socket</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
           <span class="nx">input</span><span class="p">.</span><span class="nx">value</span> <span class="o">=</span> <span class="s2">&#34;&#34;</span><span class="p">;</span>
       <span class="p">};</span>
   <span class="p">}</span>
<span class="p">&lt;/</span><span class="nt">script</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nt">input</span> <span class="na">id</span><span class="o">=</span><span class="s">&#34;input&#34;</span> <span class="na">style</span><span class="o">=</span><span class="s">&#34;width: 100%;&#34;</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">body</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="http20">HTTP2.0</h3>
<p>HTTP/1.1 的性能瓶颈主要有以下这些：</p>
<ul>
<li>一条连接同时只能发送一个请求；</li>
<li>请求只能从客户端发起；</li>
<li>请求/响应首部未经压缩就直接发送，首部信息越多延迟越大；</li>
<li>每次请求/响应都会发送冗长的首部信息，造成通信的浪费；</li>
</ul>
<p>为了解决这些问题，HTTP/2.0 会对 HTTP 首部（或者叫做 HTTP 头）进行一定的压缩，将原来每次通信都要携带的大量头信息（键值对）在两端建立一个索引表，对相同的头只发送索引表中的索引。</p>
<p>另外，HTTP/2.0 协议会将一个 TCP 连接切分成多个流，每个流都有自己的 ID，而且流可以是客户端发往服务端，也可以是服务端发往客户端，为了解决并发请求导致响应慢的问题，还可以为流设置优先级。HTTP/2.0 还将所有的传输信息分割为更小的消息和帧，并对它们采用二进制格式编码，常见的帧有 Header 帧，用于传输 HTTP 头信息，并且会开启一个新的流；再就是 Data 帧，用来传输 HTTP 报文实体，多个 Data 帧属于同一个流。</p>
<p>通过这两种机制，HTTP/2.0 的客户端可以将多个请求分到不同的流中，以实现在一个 TCP 连接上处理所有请求，然后将请求内容拆分成帧，进行二进制传输，这些帧可以打散乱序发送，然后根据每个帧首部的流标识符重新组装，并且可以根据优先级，决定优先处理哪个流的数据。</p>
<p>这样一来，HTTP/2.0 成功消除了 HTTP/1.1 的性能瓶颈和限制，减少了 TCP 连接数对服务器性能的影响，同时可以将页面的多个 css、js、 图片等资源通过一个数据链接进行传输，能够加快页面组件的传输速度。</p>
<p>HTTP/2.0 虽然大大增加了并发性，但还是有问题的，为 HTTP/2.0 还是基于 TCP 协议的，TCP 协议在建立连接时有额外的开销，在处理包时有严格的顺序要求，当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传之后才能继续进行。要解决这些问题只能通过 UDP 协议来实现才可以最大化提升 Web 的性能，不过这就属于另一个话题了。</p>
<h2 id="流媒体协议">流媒体协议</h2>
<p><img src="/img/Live-process.png" alt=""></p>
<h3 id="视频压缩和编码"><strong>视频压缩和编码</strong></h3>
<p>视频播放，其实就是快速播放一系列连续的图片而已，其中的每一张图片称之为一帧，图片是由像素构成的，每个像素由 RGB 三种颜色构成，每个颜色又由 8bit 二进制来表示，三种颜色就是 24 个 bit，假设构成视频的图片平均都是由 <code>1024*768</code> 像素（有时我们也将这个单位称之为分辨率）组成，这样下来，一秒钟视频的容量就是：<code>30*1024*768*24 bit = 566,231,040 bit = 70,778,880 Byte = 67.5 MB</code>，，通过编码对视频进行压缩，在保证清晰度的前提下实现以尽可能少的比特数存储视频数据。</p>
<p><strong>两种标准</strong></p>
<ul>
<li>国际电信联盟电信标准化部门（简称 ITU-T）旗下的 <strong>VCEG</strong>（Video Coding Experts Group，视频编码专家组），因为是电信联盟，所以他们最初做视频编码主要侧重传输，这个编码组制定的视频通信协议包括 H.261、 H.262、H.263、H.264、H.265 等</li>
<li>国际标准组织（简称 ISO）旗下的 <strong>MPEG</strong>（Moving Picture Experts Group，动态图像专家组），他们本来是做视频存储的，例如将编码后的视频保存在 VCD 和 DVD 中，随着 VCD 和 DVD 的消逝，后来也慢慢侧重视频传输了，这个编码组制定了的视频编码标准包括 MPEG-1、MPEG-2、MPEG-4、MPEG-7 等</li>
<li>后来，ITU-T VCEG 与 ISO MPEG 联合制定了 <code>H.264/MPEG-4</code>（两者等价，是同一个标准，也被称作 AVC） <code>AVI</code>、<code>MPEG</code>、<code>RMVB</code>、<code>MP4</code>、<code>MOV</code>、<code>FLV</code>、<code>WebM</code>、<code>WMV</code>、<code>ASF</code>、<code>MKV</code> 等即是在该标准下实现</li>
</ul>
<h3 id="常见流媒体协议"><strong>常见流媒体协议</strong></h3>
<ul>
<li>
<p><strong>HTTP 和 HLS</strong></p>
<ul>
<li>
<p>HTTP：最初的HTTP协议就是通用的 HTTP 文件渐进式下载，无法快进，后来可以在 HTTP 请求头中通过 Range 字段设置偏移量来实现跳转</p>
</li>
<li>
<p>HLS（HTTP Live Streaming）：主要用于在 iOS 系统中实现流媒体的直播和点播</p>
<blockquote>
<p>HLS 直播最大的不同在于，直播客户端获取到的并不是一个完整的数据流，HLS协议在服务器端将直播数据流存储为连续的、很短时长的媒体文件（MPEG-TS格式），而客户端则不断下载并播放这些小文件</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>RTP和RTCP</strong></p>
<ul>
<li>RTP（Real-time Transport Protoco）：RTP 由紧密连接的两个部分组成：
<ul>
<li>RTP 协议：传送具有实时属性的数据（建立在 UDP 协议之上的）；</li>
<li>RTP 控制协议（简称 RTCP）：监控服务质量并传送正在进行的会话参与者的相关信息。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>RTSP</strong></p>
<ul>
<li>RTSP（Real Time Streaming Protocol）在体系结构上位于 RTP 和 RTCP 之上，是一种双向实时数据传输协议，它允许客户端向服务器端发送请求，如回放、快进、倒退等操作。RTSP 可基于 RTP 来传送数据，还可以选择 TCP、UDP、组播 UDP 等通道来发送数据，具有很好的扩展性</li>
<li>RTSP 协议的优势在于可以控制到视频帧，因此可以承载实时性很高的应用，这个优点也是相对于 HTTP 传输方式的最大优点</li>
<li>iOS 系统不支持该协议，Andriod 系统原生支持</li>
</ul>
</li>
<li>
<p>**RSVP：**即资源预订协议，使用 RSVP 预留一部分网络资源（即带宽），能在一定程度上为流媒体的传输提供 QoS。RSVP、RTSP 与 RTP 协议工作在不同的层次，如下图所示：</p>
<p><img src="/img/network-protocol_22.png" alt=""></p>
</li>
<li>
<p><strong>RTMP：</strong>（Real Time Messaging Protocol，实时消息传输协议）是 Adobe 公司为 Flash 播放器和服务器之间音频、视频和数据传输开发的流媒体协议。它有以下三种变种：</p>
<ul>
<li>工作在 TCP 之上的明文协议，使用端口 1935；</li>
<li>RTMPT 封装在 HTTP 请求之中，可穿越防火墙；</li>
<li>RTMPS 类似 RTMPT，但使用的是 HTTPS 连接。</li>
</ul>
<blockquote>
<p>RTMP 协议采用实时的流式传输，所以不会缓存文件到客户端，因此用户想下载 RTMP 协议下的视频是比较难的，该协议下的视频流可以随便拖动，可以从任意时间点向服务器发送请求进行播放，并不需要视频有关键帧。相比而言，HTTP 协议下视频需要有关键帧才可以拖动。RTMP 协议可以支持点播、回放和直播。</p>
</blockquote>
</li>
<li>
<p><strong>MMS：</strong>（Microsoft Media Server Protocol，微软媒体服务协议）是用来访问并流式接收 Windows 媒体服务器中 <code>.asf</code> 文件的一种协议。MMS 协议用于访问 Windows Media 发布点上的单播内容，是连接Windows Media 单播服务的默认方法。如果用户在 Windows Media Player 中键入一个 URL 以连接内容，而不是通过超链接，则必须使用 MMS 协议引用该流。</p>
</li>
</ul>
<h3 id="基于rtmp的视频直播流程"><strong>基于RTMP的视频直播流程</strong></h3>
<ul>
<li>
<p><strong>推流：</strong></p>
<blockquote>
<p>在实际开发中，通常通过 FFmpeg 进行推流</p>
</blockquote>
<ol>
<li>主播在客户端<strong>采集</strong>视频</li>
<li>客户端软件会对视频进行<strong>编码</strong>以压缩视频</li>
<li>通过 RTMP 协议将这个二进制的视频流打包成网络包发送给服务器</li>
</ol>
</li>
<li>
<p><strong>接流：</strong></p>
<blockquote>
<p>RTMP 是基于 TCP 的，因而双方需要建立一个 TCP 连接，在 TCP 连接的基础上，还需要建立一个 RTMP 连接（沟通 RTMP 协议的版本号和时间戳）</p>
</blockquote>
<ol>
<li>客户端发送 <code>C0</code> 表示自己的版本号，不必等对方的回复，然后发送 <code>C1</code> 表示自己的时间戳</li>
<li>服务器只有在收到 <code>C0</code> 的时候，才会返回 <code>S0</code>，表明自己的版本号，如果版本不匹配，可以断开连接。服务器发送完 <code>S0</code> 后，也不用等什么，就直接发送自己的时间戳 <code>S1</code></li>
<li>客户端收到 <code>S1</code> 的时候，发一个知道了对方时间戳的 <code>ACK C2</code></li>
<li>服务器收到 <code>C1</code> 的时候，发一个知道了对方时间戳的 <code>ACK S2</code>。于是，握手完成，连接建立成功</li>
<li>握手之后，双方需要互相传递一些控制信息，例如 Chunk 块的大小、窗口大小等。真正传输数据的时候，还需要创建一个 Stream，然后通过这个 Stream 来推流</li>
</ol>
</li>
<li>
<p><strong>流处理：</strong> 获取到视频流后还要对视频流进行处理，以适配不同客户端的各种协议，从而方便观看直播的观众拉取到本地观看</p>
</li>
<li>
<p><strong>拉流：</strong> 观众可以通过 RTMP 协议或其他协议从流媒体服务器上拉取视频流（与主播推送视频流类似，先要建立 RTMP 连接，然后创建一个 Stream 用于拉流）</p>
<blockquote>
<p>如果同时观看直播的观众很多，都去同一个地方拉取，服务器压力会很大，所以需要通过 <strong>CDN（分发网络）</strong> 提升直播流畅度</p>
</blockquote>
</li>
<li>
<p><strong>解码&amp;播放：</strong> 将解码参数以及由 NALU 组成的一个个帧，将<strong>解码</strong>之后的帧交给播放器<strong>播放</strong>，就可以看到直播视频画面了</p>
</li>
</ul>
<h3 id="流媒体cdn"><strong>流媒体CDN</strong></h3>
<p>对于普通的静态资源（HTML、CSS、JavaScript、图片等小文件）来讲，内容的分发往往采取拉取的方式，当发现未命中的时候，再去上一级进行拉取。但是，流媒体（视频、音频等大文件）数据量大，如果出现回源，压力会比较大，所以往往采取主动推送的模式，将热点数据主动推送到边缘节点。具体而言，以直播为例，主播在开始直播时，就会将视频推送到就近 CDN 节点缓存，然后观众观看直播的时候，也会就近从 CDN 边缘节点拉取视频，如果该节点没有资源，会从其它 CDN 节点同步再返回给观众。看直播往往是有时延的，这个时延就是从主播端采集视频到观众端开始播放相应应视频的时间差。</p>
<h4 id="防盗链">防盗链</h4>
<ul>
<li>HTTP 头的 <code>Referer</code> 字段：
<ul>
<li>当浏览器发送请求的时候，一般会带上 Referer，告诉服务器是从哪个页面链接过来的，如果不是来自本站，就阻止访问或者跳到其它链接</li>
</ul>
</li>
<li>时间戳防盗链
<ol>
<li>和 CDN 厂商约定一个加密字符串（KEY）</li>
<li>客户端取出当前的时间戳，要访问的资源及其路径，连同加密字符串（KEY）通过签名算法得到一个字符串，然后生成一个下载链接，带上这个签名字符串和截止时间戳去访问 CDN</li>
<li>在 CDN 服务端，根据取出的过期时间，和当前 CDN 节点时间进行比较，确认请求是否过期</li>
<li>然后 CDN 服务端有了资源及路径，时间戳，以及约定的加密字符串，根据相同的签名算法计算签名，如果匹配则一致，访问合法，才会将资源返回给客户</li>
</ol>
</li>
<li>回源鉴权</li>
<li>IP黑白名单</li>
</ul>
<h2 id="rpc协议">RPC协议</h2>
<p>所谓 RPC 指的是 Remote Procedure Call，即远程方法调用（也叫远程服务调用、远程过程调用），这也是微服务架构的前导篇，因为微服务里面远程服务之间就是通过 RPC 协议进行数据传输的。</p>
<ul>
<li><strong>单体应用：</strong> 将应用的所有服务部署到一台机器上
<ul>
<li>随着业务功能的复杂度增加，团队之间的协作和代码合并越来越困难</li>
<li>随着代码仓库代码量的增加，应用部署时间越来越长，这就为上线期间线上系统的稳定性和代码回滚带来风险</li>
<li>单体应用将所有服务打包到一个应用里面，如果某个功能或资源不可用，会导致整个应用不可用</li>
</ul>
</li>
<li><strong>微服务应用：</strong> 通过微服务架构对服务进行拆分，将原来的单体应用拆分成多个子服务
<ul>
<li>多个服务独立部署和维护导致上线的复杂度增加</li>
<li>出现问题后调试的复杂度增加</li>
<li>远程服务调用过程中参数传递和数据格式的约定&hellip;</li>
</ul>
</li>
<li><strong>本地方法调用：</strong> 在单体应用中，所有服务都打包在一个应用里面，我们只需要通过本地方法即可调用其他的服务</li>
<li><strong>远程方法调用：</strong> 不同的服务部署在不同的机器，需要通过网络传输约定调用方法名、参数和返回数据才能完成一个完整的方法调用
<ul>
<li>如何规定远程调用的语法</li>
<li>如何传递参数</li>
<li>如何表示数据</li>
<li>服务发现问题</li>
<li>网络传输问题</li>
</ul>
</li>
</ul>
<p>常见的开源 RPC 框架来处理这些底层问题（如 Spring Cloud、Dubbo、gRRC、Thrift、Hprose 等），现有的 RPC 框架都是基于 Andrew D. Birrell 和 Bruce Jay Nelson 的论文实现的：<a href="http://www.cs.cmu.edu/~dga/15-712/F07/papers/birrell842.pdf">Implementing Remote Procedure Calls</a>，<a href="https://www.jianshu.com/p/91be39f72c74">中文译文</a>。</p>
<p><img src="/img/network-protocol_23.jpg" alt=""></p>
<h2 id="推荐阅读">推荐阅读</h2>
<blockquote>
<p><a href="https://xueyuanjun.com/books/network-protocols">网络协议概论</a></p>
</blockquote>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8Aphp%E5%AE%9E%E7%8E%B0/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">数据结构及PHP实现</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/laravel8%E5%8F%82%E8%80%83%E4%B9%A6%E5%86%8C/">
            <span class="next-text nav-default">Laravel8参考书册</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="http://github.com/zs368/" class="iconfont icon-github" title="github"></a>
      <a href="http://bilibili.com" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://zs368.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">zs368</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.2517c0eb67172a0bae917de4af59b10ca2531411a009d4c0b82f5685259e5771.js"></script>








</body>
</html>
