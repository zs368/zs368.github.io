<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>杂 - OxO</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="zs" /><meta name="description" content="" /><meta name="keywords" content="杂" />






<meta name="generator" content="Hugo 0.84.3 with theme even" />


<link rel="canonical" href="https://zs368.github.io/post/%E6%9D%82/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.24752eee7d244519907709610f39db5d85a57e527ff033fcae4457858307d262.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="杂" />
<meta property="og:description" content="" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zs368.github.io/post/%E6%9D%82/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2020-10-29T11:54:51&#43;08:00" />
<meta property="article:modified_time" content="2020-10-29T11:54:51&#43;08:00" />

<meta itemprop="name" content="杂">
<meta itemprop="description" content=""><meta itemprop="datePublished" content="2020-10-29T11:54:51&#43;08:00" />
<meta itemprop="dateModified" content="2020-10-29T11:54:51&#43;08:00" />
<meta itemprop="wordCount" content="5037">
<meta itemprop="keywords" content="杂," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="杂"/>
<meta name="twitter:description" content=""/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">zs368</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/info/">
        <li class="mobile-menu-item">Info</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">zs368</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/info/">Info</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">杂</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-10-29 </span>
        <div class="post-category">
            <a href="/categories/%E7%BC%96%E7%A8%8B/"> 编程 </a>
            </div>
          <span class="more-meta"> 5037 words </span>
          <span class="more-meta"> 11 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#计算机基础">计算机基础</a>
      <ul>
        <li><a href="#进程线程协程">进程、线程、协程</a></li>
        <li><a href="#网络协议">网络协议</a></li>
        <li><a href="#认证机制">认证机制</a></li>
      </ul>
    </li>
    <li><a href="#常用技巧">常用技巧</a>
      <ul>
        <li><a href="#crontab定时任务">crontab定时任务</a></li>
        <li><a href="#wget抓取整站">wget抓取整站</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="计算机基础">计算机基础</h2>
<h3 id="进程线程协程">进程、线程、协程</h3>
<blockquote>
<p><a href="https://juejin.im/post/6844903607892967432">文章来源</a></p>
</blockquote>
<h4 id="进程">进程</h4>
<ul>
<li>进程是操作系统对一个正在运行的程序的一种抽象结构。</li>
<li>进程是指在操作系统中能独立运行并作为资源分配的基本单位，由一组机器指令、数据和堆栈等组成的能独立运行的活动实体。</li>
<li>操作系统可以同时运行多个进程，多个进程直接可以并发执行和交换信息。</li>
<li>进程在运行是需要一定的资源，如CPU、存储空间和I/O设备等。</li>
</ul>
<p>因此进程的创建和销毁都是相对于系统资源,所以是一种比较昂贵的操作。 进程有三个状态:</p>
<ol>
<li>等待态：等待某个事件的完成；</li>
<li>就绪态：等待系统分配处理器以便运行；</li>
<li>运行态：占有处理器正在运行。</li>
</ol>
<p>进程是抢占式的争夺CPU运行自身,而CPU单核的情况下同一时间只能执行一个进程的代码,但是多进程的实现则是通过CPU飞快的切换不同进程,因此使得看上去就像是多个进程在同时进行.</p>
<blockquote>
<p>通信问题:   由于进程间是隔离的,各自拥有自己的内存内存资源, <em>因此相对于线程比较安全</em>, 所以不同进程之间的数据只能通过 <em>IPC(Inter-Process Communication)</em> 进行通信共享.</p>
</blockquote>
<h4 id="线程">线程</h4>
<ul>
<li>线程属于进程</li>
<li>线程共享进程的内存地址空间，但也拥有自己的资源，例如，栈，寄存器等等。</li>
<li>线程调度能大幅度减小调度的成本（相对于进程来说），线程的切换不会引起进程的切换</li>
<li>线程的引入进一步提高了操作系统的并发性，线程能并发执行</li>
</ul>
<p>多线程环境中，父线程终止，全部子线程被迫终止(没有了资源)。任何一个子线程终止一般不会影响其他线程，除非子线程执行了 <code>exit()</code> 系统调用。</p>
<p>但多进程而不会,一个进程挂了,另一个进程依然照样运行。</p>
<h4 id="协程">协程</h4>
<ul>
<li>协程是属于线程的。协程程序是在线程里面跑的，因此协程又称微线程和纤程等</li>
<li>协没有线程的上下文切换消耗。协程的调度切换是用户(程序员)手动切换的,因此更加灵活,因此又叫用户空间线程.</li>
<li>原子操作性。由于协程是用户调度的，所以不会出现执行一半的代码片段被强制中断了，因此无需原子操作锁。</li>
</ul>
<p><strong>协程的实现：迭代器和生成器</strong></p>
<ul>
<li>迭代器： 实现了迭代接口的类,接口函数例如:current,key,next,rewind,valid。迭代器最基本的规定了对象可以通过next返回下一个值，而不是像数组，列表一样一次性返回。语言实现：在Java的foreach遍历迭代器对(数组)，Python的for遍历迭代器对象(tuple，list，dist)。</li>
<li>生成器： 使用 <em>yield</em> 关键字的函数,可以多次返回值，生成器实际上也算是实现了迭代器接口(协议)。即生成器也可通过next返回下一个值。</li>
</ul>
<blockquote>
<p>协程举例：在Python或PHP中，使用了yield的函数为生成器函数，即可以多次返回值。则生成器可以暂停一下，转而执行其他代码，再回来继续执行函数往下的代码。</p>
</blockquote>
<h4 id="区别">区别</h4>
<p><strong>进程与线程的区别</strong></p>
<ul>
<li><strong>进程是系统分配资源的最小单位</strong></li>
<li><strong>线程是CPU调度的最小单位</strong></li>
<li><strong>由于默认进程内只有一个线程,所以多核CPU处理多进程就像是一个进程一个核心</strong></li>
</ul>
<p><strong>进程切换分3步</strong>:</p>
<ol>
<li>切换页目录以使用新的地址空间</li>
<li>切换内核栈</li>
<li>切换硬件上下文</li>
</ol>
<p><strong>而线程切换只需要第2、3步</strong>,因此进程的切换代价比较大</p>
<h3 id="网络协议">网络协议</h3>
<blockquote>
<p>OSI七层模型是万能的国际标准化组织(ISO)提出的一个试图使各种计算机在世界范围内互连的理想标准，说白了理想和现实的差距就是七层模型和五层模型的差距。具体分类如下表：</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">七层模型</th>
<th style="text-align:center">五层模型</th>
<th style="text-align:center">四层模型</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用层</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">表示层</td>
<td style="text-align:center">应用层</td>
<td style="text-align:center">应用层</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">会话层</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
<tr>
<td style="text-align:center">传输层</td>
<td style="text-align:center">传输层</td>
<td style="text-align:center">传输层</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">网络层</td>
<td style="text-align:center">网络层</td>
<td style="text-align:center">网络层</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">数据链路层</td>
<td style="text-align:center">链接层/实体层</td>
<td></td>
</tr>
<tr>
<td style="text-align:center">物理层</td>
<td style="text-align:center">物理层</td>
<td style="text-align:center"></td>
<td></td>
</tr>
</tbody>
</table>
<ul>
<li>从本质上来区分，HTTP，WebSocket，TCP，UDP，IP都是协议，而TCP/IP是不同协议的组合，你也可以称之为协议栈，协议族，TCP/IP模型等等都可以。
而Socket（套接字）才是真正能操作的东西。Socket的本质是API，是先人对TCP/IP协议族的抽象或者说封装，它就像一个门面，给你一个操作TCP/IP协议的入口，来建立Socket连接。（值得一提的是，此Socket是指网络编程下的Socket，而不是Unix中的Socket。虽然概念相似，但是Unix中的Socket不是基于这些乱七八糟的协议，而是基于操作系统本身的文件系统。）</li>
<li>从分层上来区分，HTTP，WebSocket是应用层协议，TCP，UDP是传输层协议，IP是网络层协议。</li>
</ul>
<h4 id="tcp">TCP</h4>
<blockquote>
<p>TCP连接之后，客户端和服务器可以互相发送和接收消息，在客户端或者服务器没有主动断开之前，连接一直存在，故称为长连接</p>
</blockquote>
<ul>
<li>优点
<ul>
<li>可靠性、全双工协议、开源支持多、应用较广泛</li>
<li>面向连接、研发成本低、</li>
<li>报文内容不限制（IP层自动分包，重传，不大于1452bytes）、先发先至</li>
</ul>
</li>
<li>缺点
<ul>
<li>操作系统：较耗内存，支持连接数有限</li>
<li>设计：协议较复杂，自定义应用层协议</li>
<li>网络：网络差情况下延迟较高</li>
<li>传输：效率低于UDP协议</li>
</ul>
</li>
<li>特性
<ul>
<li>面向连接、可靠性、全双工协议、基于IP层、OSI参考模型位于传输层、适用于二进制传输</li>
</ul>
</li>
</ul>
<h4 id="udp">UDP</h4>
<ul>
<li>优点
<ul>
<li>操作系统：并发高，内存消耗较低、</li>
<li>传输：效率高，网络延迟低、传输模型简单，研发成本低</li>
</ul>
</li>
<li>缺点
<ul>
<li>协议不可靠、单向协议、开源支持少、</li>
<li>报文内容有限，一般数据包限定64KB之内，先发未必先至、</li>
<li>设计：协议设计较复杂</li>
<li>网络：网络差，而且丢数据报文</li>
</ul>
</li>
<li>特性
<ul>
<li>无连接，不可靠，基于IP协议层，OSI参考模型位于传输层，最大努力交付，适用于二进制传输</li>
</ul>
</li>
</ul>
<h4 id="http">HTTP</h4>
<blockquote>
<p>HTTP是基于TCP协议的应用，请求时需建立TCP连接，而且请求包中需要包含请求方法，URI，协议版本等信息，请求结束后断开连接，完成一次请求/响应操作。故称为短连接。</p>
</blockquote>
<ul>
<li>优点
<ul>
<li>协议较成熟，应用广泛、基于TCP/IP，拥有TCP优点、研发成本很低，开发快速、开源软件较多，nginx,apache,tomact等</li>
</ul>
</li>
<li>缺点
<ul>
<li>无状态无连接、只有PULL模式，不支持PUSH、数据报文较大</li>
</ul>
</li>
<li>特性
<ul>
<li>基于TCP/IP应用层协议、无状态，无连接、支持C/S模式、适用于文本传输</li>
</ul>
</li>
</ul>
<h4 id="websocket">WebSocket</h4>
<blockquote>
<p>WebSocket也是一种协议，并且也是基于TCP协议的。具体流程是WebSocket通过HTTP先发送一个标记了 Upgrade 的请求，服务端解析后开始建立TCP连接，省去了HTTP长连接每次请求都要上传header的冗余，可以理解为WebSocket是HTTP的优化，但WebSocket不仅仅在Web应用程序上得到支持。</p>
</blockquote>
<ul>
<li>优点
<ul>
<li>协议较成熟、基于TCP/IP，拥有TCP优点、数据报文较小，包头非常小、面向连接，有状态协议、开源较多，开发较快</li>
</ul>
</li>
<li>缺点
<ul>
<li>没发现啥缺点</li>
</ul>
</li>
<li>特性
<ul>
<li>有状态，面向连接、数据报头较小、适用于WEB3.0，以及其他即时联网通讯</li>
</ul>
</li>
</ul>
<h4 id="协议选择">协议选择</h4>
<p>通过以上对协议特性分析，我想大家心里已经有低儿了。建议：</p>
<p>1、对于弱联网类游戏，必须消除类的，卡牌类的，可以直接HTTP协议，考虑安全的话直接HTTPS，或者对内容体做对称加密；</p>
<p>2、对于实时性，交互性要求较高，且team有过相关经验，可以优先选择websocket，其次TCP协议；</p>
<p>3、对于实时性要求极高，且可达性要求一般可以选择UDP协议；</p>
<p>4、局域网对战类，赛车类，直接来UDP协议吧（公网对战，P2P的UDP还得“打洞”处理）</p>
<h3 id="认证机制">认证机制</h3>
<h4 id="http-basic-auth">HTTP Basic Auth</h4>
<p>HTTP Basic Auth 在HTTP中，基本认证是一种用来允许Web浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种登录验证方式，通常用户名和明码会通过HTTP头传递。</p>
<ol>
<li>在发送之前是以用户名追加一个冒号然后串接上口令，并将得出的结果字符串再用Base64算法编码。</li>
<li>将Base64编码的字符串发送出去，由接收者解码得到一个由冒号分隔的用户名和口令的字符串。</li>
</ol>
<ul>
<li><strong>优点</strong>
<ul>
<li>基本上所有流行的网页浏览器都支持基本认证</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li>Base64编码是可逆的，所以用户名和密码可以认为是明文，只有在客户端和服务器主机之间的连接是安全可信的前提下才可以使用。</li>
</ul>
</li>
</ul>
<h4 id="oauth">OAuth</h4>
<p>OAuth 是一个关于授权（authorization）的开放网络标准。允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。现在的版本是2.0版。严格来说，OAuth2不是一个标准协议，而是一个安全的授权框架。它详细描述了系统中不同角色、用户、服务前端应用（比如API），以及客户端（比如网站或移动App）之间怎么实现相互认证。</p>
<ol>
<li>用户打开客户端以后，客户端要求用户给予授权</li>
<li>用户同意给予客户端授权</li>
<li>客户端使用上一步获得的授权，向认证服务器申请令牌</li>
<li>认证服务器对客户端进行认证以后，确认无误，同意发放令牌</li>
<li>客户端使用令牌，向资源服务器申请获取资源</li>
<li>资源服务器确认令牌无误，同意向客户端开放资源。</li>
</ol>
<ul>
<li>Third-party application: 第三方应用程序，又称&quot;客户端&quot;（client）</li>
<li>HTTP service：HTTP服务提供商</li>
<li>Resource Owner：资源所有者，通常称&quot;用户&quot;（user）</li>
<li>User Agent：用户代理，比如浏览器</li>
<li>Authorization server：认证服务器，即服务提供商专门用来处理认证的服务器</li>
<li>Resource server：资源服务器，即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器</li>
</ul>
<p><img src="../img/OAuth2.0.jpg" alt=""></p>
<h4 id="jwt-认证">JWT 认证</h4>
<p>Json web token (JWT), 根据官网的定义，是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519)。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<ol>
<li>头部（Header）：将头部进行 Base64URL 加密（该加密是可以对称解密的)
<ul>
<li>声明加密的算法，通常直接使用 HMAC SHA256</li>
<li>声明类型，这里是jwt</li>
</ul>
</li>
<li>载荷（payload）：将头部进行 Base64URL 加密（该加密是可以对称解密的)
<ul>
<li>标准中注册声明</li>
<li>公共的声名：可以添加任何的信息（不建议存放敏感信息）</li>
<li>私有的声明：提供者和消费者所共同定义的声明（不建议存放敏感信息）</li>
</ul>
</li>
<li>签名（signature）：根据alg算法与私有秘钥进行加密得到的签名字串，只能在服务端解密   <code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),SECREATE_KEY)</code>
<ul>
<li>header (base64后的)</li>
<li>payload (base64后的)</li>
<li>secret</li>
</ul>
</li>
</ol>
<ul>
<li><strong>优点</strong>
<ul>
<li>体积小，因而传输速度快</li>
<li>传输方式多样，可以通过URL/POST参数/HTTP头部等方式传输</li>
<li>严格的结构化，自身（在 payload 中）就包含了所有与用户相关的验证消息，如用户可访问路由、访问有效期等信息，服务器无需再去连接数据库验证信息的有效性，并且 payload 支持为你的应用而定制化</li>
<li>支持跨域验证，可以应用于单点登录</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li>最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑</li>
<li>本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证</li>
</ul>
</li>
<li><strong>规范</strong>
<ul>
<li>默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次</li>
<li>不加密的情况下，不能将秘密数据写入 JWT</li>
<li>为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输</li>
</ul>
</li>
</ul>
<h2 id="常用技巧">常用技巧</h2>
<h3 id="crontab定时任务">crontab定时任务</h3>
<p><a href="https://crontab.guru/">crontab时间预览</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">sudo service crond start     <span class="c1">#启动服务</span>
sudo service crond stop      <span class="c1">#关闭服务</span>
sudo service crond restart   <span class="c1">#重启服务</span>
sudo service crond reload    <span class="c1">#重新载入配置</span>
sudo service crond status    <span class="c1">#查看服务状态</span>

crontab <span class="o">[</span>-u username<span class="o">]</span>　　　　  <span class="c1">#省略用户表表示操作当前用户的crontab</span>
    -e      <span class="o">(</span>编辑工作表<span class="o">)</span>
    -l      <span class="o">(</span>列出工作表里的命令<span class="o">)</span>
    -r      <span class="o">(</span>删除工作作<span class="o">)</span>
    
vim /etc/crontab
<span class="c1"># .---------------- minute (0 - 59) </span>
<span class="c1"># |  .------------- hour (0 - 23)</span>
<span class="c1"># |  |  .---------- day of month (1 - 31)</span>
<span class="c1"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ... </span>
<span class="c1"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7)  OR</span>
<span class="c1">#sun,mon,tue,wed,thu,fri,sat </span>
<span class="c1"># |  |  |  |  |</span>
<span class="c1"># *  *  *  *  *  command to be executed</span>

<span class="c1">#每天四点执行Tp自定义任务</span>
<span class="m">0</span> <span class="m">4</span>  *  *  *  *  root php /www/wwwroot/应用名/think 自定义命令名称 
</code></pre></td></tr></table>
</div>
</div><h3 id="wget抓取整站">wget抓取整站</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">wget -r -p -np -k http://www.wohaoba.com/
<span class="c1">#-r  递归</span>
<span class="c1">#-p,  --page-requisites（页面必需元素）</span>
<span class="c1">#-np, --no-parent（不追溯至父级）</span>
<span class="c1">#-k  将下载的HTML页面中的链接转换为相对链接即本地链接</span>
</code></pre></td></tr></table>
</div>
</div><p>找了几个wget技巧，发一下。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ wget -r -np -nd http://www.wohaoba.com/packages/
<span class="c1">#这条命令可以下载 http://example.com 网站上 packages 目录中的所有文件。其中，-np的作用是不遍历父目录，-nd 表示不在本机重新创建目录结构。</span>

$ wget -r -np -nd --accept<span class="o">=</span>iso http://www.qqfdc.com/centos-5/i386/
<span class="c1">#与上一条命令相似，但多加了一个 --accept=iso 选项，这指示 wget 仅下载 i386目录中所有扩展名为 iso 的文件。你也可以指定多个扩展名，只需用逗号分隔即可。</span>

$ wget -i filename.txt
<span class="c1">#此命令常用于批量下载的情形，把所有需要下载文件的地址放到 filename.txt 中，然后 wget 就会自动为你下载所有文件了。</span>

$ wget -c http://www.wohaoba.com/really-big-file.iso
<span class="c1">#这里所指定的 -c 选项的作用为断点续传。</span>

$ wget -m -k <span class="o">(</span>-H<span class="o">)</span> http://www.wohaoba.com/
<span class="c1">#该命令可用来镜像一个网站，wget 将对链接进行转换。如果网站中的图像是放在另外的站点，那么可以使用 -H 选项</span>
</code></pre></td></tr></table>
</div>
</div>
    </div>

    
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E6%9D%82/">杂</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/laravel-example/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">laravel-example</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/laradock%E8%B8%A9%E5%9D%91%E7%AC%94%E8%AE%B0/">
            <span class="next-text nav-default">Laradock踩坑笔记</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="http://github.com/zs368/" class="iconfont icon-github" title="github"></a>
      <a href="http://bilibili.com" class="iconfont icon-bilibili" title="bilibili"></a>
  <a href="https://zs368.github.io/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2020 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">zs368</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.2517c0eb67172a0bae917de4af59b10ca2531411a009d4c0b82f5685259e5771.js"></script>








</body>
</html>
